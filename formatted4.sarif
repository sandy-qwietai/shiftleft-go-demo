{
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/main/sarif-2.1/schema/sarif-schema-2.1.0.json",
  "version": "2.1.0",
  "runs": [
    {
      "automationDetails": {
        "description": {
          "text": "Static Analysis Security Test results using ng-sast"
        },
        "guid": "74250752-2676-4a6a-8011-bcbbf66305af"
      },
      "conversion": {
        "invocation": {
          "commandLine": "",
          "endTimeUtc": "2025-06-27T07:46:12Z",
          "executionSuccessful": true,
          "workingDirectory": {
            "index": 0,
            "uri": ""
          }
        },
        "tool": {
          "driver": {
            "name": "ng-sast"
          }
        }
      },
      "invocations": [
        {
          "endTimeUtc": "2025-06-27T07:46:12Z",
          "executionSuccessful": true,
          "workingDirectory": {
            "index": 0,
            "uri": ""
          }
        }
      ],
      "language": "en-US",
      "newlineSequences": [
        "\r\n",
        "\n"
      ],
      "results": [
        {
          "fingerprints": {
            "evidenceFingerprint": "b54659c92c4946c5e13d77efde04e5190705f2a7bee889b82cc478bba84cf750"
          },
          "baselineState": "new",
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "go.mod"
                }
              }
            }
          ],
          "message": {
            "markdown": "pkg:golang/github.com/tidwall/gjson@v1.9.2",
            "text": "pkg:golang/github.com/tidwall/gjson@v1.9.2"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "7.5"
          },
          "rank": -1,
          "ruleId": "oss_vuln/a49552ffe7ac568249b08ccad3208275",
          "ruleIndex": 0
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "64d6f1f3d83942ba3b31d0efbf2c23cf4890b5f5eaf9e2562898b1a128d80f89"
          },
          "baselineState": "new",
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "go.mod"
                }
              }
            }
          ],
          "message": {
            "markdown": "pkg:golang/github.com/gen2brain/go-unarr@v0.1.1",
            "text": "pkg:golang/github.com/gen2brain/go-unarr@v0.1.1"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "critical",
            "score": "9.8"
          },
          "rank": -1,
          "ruleId": "oss_vuln/5e8b09a9dd7eb14a3c04b026569974ab",
          "ruleIndex": 1
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "b1e90a402ca55ebe3da36bec8eb9ffb25a263baa4398163562a4a8ad3eefda53"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/server.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 3247
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "app.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 83
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "app.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 83
                }
              }
            }
          ],
          "message": {
            "markdown": "Security Misconfiguration: Web Server Without TLS Protection in `main`",
            "text": "Security Misconfiguration: Web Server Without TLS Protection in main"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "1"
          },
          "rank": -1,
          "ruleId": "http-no-ssl/68ca27584f44d372afb90a4d5cfa6976",
          "ruleIndex": 2
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "6b864f0c1a90007c4a61053f8315e0a00678fb147daf8105bbd77c8f050dd5f8"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/database/database.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 25
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1676
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1676
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Non-Constant SQL Statement in `Connect`",
            "text": "SQL Injection: Non-Constant SQL Statement in Connect"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "warning-sink-sql/8f29933f2aeb9237860702e08752127c",
          "ruleIndex": 3
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "74d151941bcf5e46b1a4a2955ccc313aa5adce3d113cc534c515bc5e27e38ec8"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 71
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1676
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1676
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Non-Constant SQL Statement in `createProfileTable`",
            "text": "SQL Injection: Non-Constant SQL Statement in createProfileTable"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "warning-sink-sql/870dab0c4977bb2c66f23bfb553401ab",
          "ruleIndex": 4
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "f85336885cda9cb4b924ec8f432710a49ede7d7a42ed49f4d067f0698083db62"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 67
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1676
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1676
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Non-Constant SQL Statement in `createProfileTable`",
            "text": "SQL Injection: Non-Constant SQL Statement in createProfileTable"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "warning-sink-sql/7f4524808dfc6947bffade7f0066f457",
          "ruleIndex": 5
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "e6a7d864bb57515d1fed0c17a151ebc6e493d69e5d222bbab2ce645c382d6fbe"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 63
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1676
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1676
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Non-Constant SQL Statement in `createProfileTable`",
            "text": "SQL Injection: Non-Constant SQL Statement in createProfileTable"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "warning-sink-sql/f61dd1bc9f8870ba6e57674b1bd4e50e",
          "ruleIndex": 6
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "5fda4f402dcdeacbee483099a7394e9aeffa9c25ee2ba06db0152f839bdd13b9"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 55
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1676
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1676
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Non-Constant SQL Statement in `createUsersTable`",
            "text": "SQL Injection: Non-Constant SQL Statement in createUsersTable"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "warning-sink-sql/b6e4ef5d675f2a2d6196428209d80e80",
          "ruleIndex": 7
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "f224325d954ef5f1394cd756ec90bc9786d044a50172b7add93dfc865ceb5b82"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 51
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1676
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1676
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Non-Constant SQL Statement in `createUsersTable`",
            "text": "SQL Injection: Non-Constant SQL Statement in createUsersTable"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "warning-sink-sql/ffc7f2703609e00dbee5a6a6c63ad619",
          "ruleIndex": 8
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "e38084e0480ec2208104d9b4c7535551d389c493b79b4454e20172272c69f4fe"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 47
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1676
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1676
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Non-Constant SQL Statement in `createUsersTable`",
            "text": "SQL Injection: Non-Constant SQL Statement in createUsersTable"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "warning-sink-sql/af6d97798ef8325f40b78476219f447a",
          "ruleIndex": 9
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "323af56300048ae6bcce1f055302dc1034be691be68dfd65a91bd93a6f04ede2"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 40
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1746
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1746
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Non-Constant SQL Statement in `Profile.UnsafeQueryGetData`",
            "text": "SQL Injection: Non-Constant SQL Statement in Profile.UnsafeQueryGetData"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "warning-sink-sql/0c86d892065812c87d0782a6ad5cd34d",
          "ruleIndex": 10
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "9977ebdf6d729e7c7bdec8f5cfb7484f2c3efd77152bdbdb42b7f623d0c271aa"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/http.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 12
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/server.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 2299
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "warning",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/server.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 2299
                }
              }
            }
          ],
          "message": {
            "markdown": "Open Redirect: Non-Constant URL Target of HTTP Redirect in `Redirect`",
            "text": "Open Redirect: Non-Constant URL Target of HTTP Redirect in Redirect"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "medium",
            "score": "4"
          },
          "rank": -1,
          "ruleId": "warning-sink-redirect/db3e076bda55a8c66c3dcd5ab6ec298d",
          "ruleIndex": 11
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "fe55869758c8f842ce0f9eb992bee643fffbaafb47b7c223216c733f788b22e2"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 37
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/server.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 2299
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "warning",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/server.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 2299
                }
              }
            }
          ],
          "message": {
            "markdown": "Open Redirect: Non-Constant URL Target of HTTP Redirect in `AuthCheck@1`",
            "text": "Open Redirect: Non-Constant URL Target of HTTP Redirect in AuthCheck@1"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "medium",
            "score": "4"
          },
          "rank": -1,
          "ruleId": "warning-sink-redirect/4b633639581f06013afa8c2b285a05e5",
          "ruleIndex": 12
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "badaf7a93bb726ac19d99b1b2a7fcca7b3017721938446e155ab656f5833fa83"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 74
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 75
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/request.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1428
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 97
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/fmt/print.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 237
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 101
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "vulnerability/xss/xss.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 101
                }
              }
            }
          ],
          "message": {
            "markdown": "Template Injection: HTTP Data Used in HTML Template via `r` in `xss2Handler`",
            "text": "Template Injection: HTTP Data Used in HTML Template via r in xss2Handler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "xss-to-html-template/a4027996d3dd4fee4d2747deff915dba",
          "ruleIndex": 13
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "6680403d4a9c71d491da1bf274697894cc75b8d331fae7d8db0168b46de1a23d"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 35
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 41
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/request.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1428
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 51
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 112
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 114
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/regexp/regexp.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 572
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 115
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 54
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/fmt/print.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 237
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 61
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "vulnerability/xss/xss.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 61
                }
              }
            }
          ],
          "message": {
            "markdown": "Template Injection: HTTP Data Used in HTML Template via `r` in `xss1Handler`",
            "text": "Template Injection: HTTP Data Used in HTML Template via r in xss1Handler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "xss-to-html-template/e4f937181fa15f5828f1ebbdd97ef9e6",
          "ruleIndex": 14
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "6d7601f18645778150d1a55fe37eac4ab92e0ce681962d99286019e64b1b7cc8"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 35
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 41
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/request.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1428
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 51
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 112
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 114
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/regexp/regexp.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 572
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 115
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 55
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/fmt/print.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 237
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 60
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "vulnerability/xss/xss.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "markdown": "Template Injection: HTTP Data Used in HTML Template via `r` in `xss1Handler`",
            "text": "Template Injection: HTTP Data Used in HTML Template via r in xss1Handler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "xss-to-html-template/8a7f4fa43141cea249c2c55fe57f54d2",
          "ruleIndex": 15
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "3dd58df8dd75b9024f5dd25a27029f199b79dba071935cfe3ab84ec2e2f07106"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 35
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 41
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/request.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1428
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 51
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 112
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 114
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/regexp/regexp.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 572
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 115
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 55
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/fmt/print.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 237
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 64
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "vulnerability/xss/xss.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 64
                }
              }
            }
          ],
          "message": {
            "markdown": "Template Injection: HTTP Data Used in HTML Template via `r` in `xss1Handler`",
            "text": "Template Injection: HTTP Data Used in HTML Template via r in xss1Handler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "xss-to-html-template/8a7f4fa43141cea249c2c55fe57f54d2",
          "ruleIndex": 15
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "f54058f8e0ac715777faa54cee421b636be1aec3c04acb8838a4cf27ed013ac6"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 35
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 41
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/request.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1428
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 51
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 112
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 114
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/regexp/regexp.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 572
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 115
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 63
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/fmt/print.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 237
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/xss/xss.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 65
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "vulnerability/xss/xss.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 65
                }
              }
            }
          ],
          "message": {
            "markdown": "Template Injection: HTTP Data Used in HTML Template via `r` in `xss1Handler`",
            "text": "Template Injection: HTTP Data Used in HTML Template via r in xss1Handler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "xss-to-html-template/3adb6c8fd0d2a901ba252577569b08cf",
          "ruleIndex": 16
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "be33f765e7a678502fa2bcc6401311549cad7ed8bf24ddd3e7d67daafc9f2485"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/crypto/md5/md5.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 101
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/idor/idor.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 163
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/idor/idor.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 165
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/hash/hash.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 33
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/hash/hash.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 33
                }
              }
            }
          ],
          "message": {
            "markdown": "Weak Hash: Usage of Weak Cryptographic Hash Function in `Md5Sum`",
            "text": "Weak Hash: Usage of Weak Cryptographic Hash Function in Md5Sum"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "3"
          },
          "rank": -1,
          "ruleId": "weak-hash/17b4f6dcd42026aecb2356eb386b38ea",
          "ruleIndex": 17
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "06117bc7f78d806e59faeb931f5726f8c6a01670959f0add15b4459dc302589d"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/crypto/md5/md5.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 101
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/csa/csa.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 64
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/csa/csa.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 66
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/hash/hash.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 33
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/hash/hash.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 33
                }
              }
            }
          ],
          "message": {
            "markdown": "Weak Hash: Usage of Weak Cryptographic Hash Function in `Md5Sum`",
            "text": "Weak Hash: Usage of Weak Cryptographic Hash Function in Md5Sum"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "3"
          },
          "rank": -1,
          "ruleId": "weak-hash/e6357875527fc2fdfa7f37273c076476",
          "ruleIndex": 18
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "0c4c5e02a3943b1914f93436ce3e8ddbb18c7ed30aecaf7bf6a4501d6c7de67b"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/crypto/md5/md5.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 101
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "user/user.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 160
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "user/user.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 162
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/hash/hash.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 33
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/hash/hash.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 33
                }
              }
            }
          ],
          "message": {
            "markdown": "Weak Hash: Usage of Weak Cryptographic Hash Function in `Md5Sum`",
            "text": "Weak Hash: Usage of Weak Cryptographic Hash Function in Md5Sum"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "3"
          },
          "rank": -1,
          "ruleId": "weak-hash/c00d9848ecbe39d0fccfc5420df95ce2",
          "ruleIndex": 19
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "8fbacea1e6cedf022811d464eb8363655a63c81bb6d2a3555811c48067b29ea7"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/sqli.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/sqli.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 29
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/cookie.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 41
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/cookie.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 42
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/request.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 457
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/cookie.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 43
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/sqli.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 45
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 32
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 39
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 36
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/fmt/print.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 237
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 40
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1746
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1746
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Attacker-controlled Data Used in SQL Query via `r` in `sqli1Handler`",
            "text": "SQL Injection: Attacker-controlled Data Used in SQL Query via r in sqli1Handler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "critical",
            "score": "9"
          },
          "rank": -1,
          "ruleId": "sql-injection-attacker-controlled/9cf3e1cbe47ecf4916466cbd4a0536eb",
          "ruleIndex": 20
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "d204565ec5daab10ce01298abae45d4a0ec6e069280c2b9f49985bf9aaf0828a"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/sqli.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 65
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/sqli.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 66
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/request.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1428
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/sqli.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 73
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 32
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 39
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 36
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/fmt/print.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 237
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/sqli/function.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 40
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 1746
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/database/sql/sql.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1746
                }
              }
            }
          ],
          "message": {
            "markdown": "SQL Injection: Attacker-controlled Data Used in SQL Query via `r` in `sqli2Handler`",
            "text": "SQL Injection: Attacker-controlled Data Used in SQL Query via r in sqli2Handler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "critical",
            "score": "9"
          },
          "rank": -1,
          "ruleId": "sql-injection-attacker-controlled/5b20b3534d2c3143e97531b5b585508a",
          "ruleIndex": 21
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "c386445ede83bd2c94bc7848e381b131050e15a224c24b9a4d3dec45e7cba273"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 23
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `LoggingMiddleware@1`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in LoggingMiddleware@1"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/e5bfbebfdc3068e21ade9da6f0b203ad",
          "ruleIndex": 22
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "eb0cd150e65f8909ab26a25e0e727bc0d3715911fa1719f63715cce300f8939c"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 23
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 26
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `LoggingMiddleware@1`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in LoggingMiddleware@1"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/e5bfbebfdc3068e21ade9da6f0b203ad",
          "ruleIndex": 22
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "d2268413c61c2a03599449cb1831be649ede40366fc44d61fa62762498731214"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 23
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 25
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/header.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 49
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `LoggingMiddleware@1`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in LoggingMiddleware@1"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/e5bfbebfdc3068e21ade9da6f0b203ad",
          "ruleIndex": 22
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "80eeb5208d3296d3365f4bee3b3ee83454541814ffc58e2877b565723ab3308b"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "app.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 37
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 41
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 34
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `indexHandler`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in indexHandler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/5a32131deea445fc16b1b1fde29bd1c6",
          "ruleIndex": 23
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "2eb37ffb76a95bdcdc2b95414c62e6d523de458432c0d2006d4fe99e26ca49c0"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setting/setting.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 45
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 41
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 34
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `setLevelAction`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in setLevelAction"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/0a1a4cd9aa85f7b751ef9d8751ba9ff7",
          "ruleIndex": 24
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "a815700dae5d254d4d3db38e7a563c5a9653b2b71193385132b6622db44d0546"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 68
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `DetectSQLMap@1`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in DetectSQLMap@1"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/dd305b38f3b52689fbfbcc8095b56134",
          "ruleIndex": 25
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "93c311dd56d3bf5ca7291a9b0672f36440b7d95d5c5bc12d61b466d48ad804e6"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "user/user.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 45
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 63
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 46
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `LoginViewHandler`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in LoginViewHandler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/abeebc310d82290692884b66e0bb7f4f",
          "ruleIndex": 26
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "b553c1a74240541ca90c8b77aaaa09a8f1548ce8c36fb1d37720e139c0efa422"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 34
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `AuthCheck@1`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in AuthCheck@1"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/ef0d7f50a5dea7592da787b4f3089581",
          "ruleIndex": 27
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "2952aea64f90671a2324f6f2ae266ed75d35a70f6962f3632eb35c6733575aad"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/setup.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 36
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 63
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 46
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `setupViewHandler`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in setupViewHandler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/6d013abff1bf54c5332ed5f58e488d43",
          "ruleIndex": 28
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "225d9b2ed1b6ae614ee6035139b46d2e0a829ace20fa341289f25f64b4055c6f"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/setup.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 58
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 63
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 46
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `setupActionHandler`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in setupActionHandler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/26bf9a433d2ee80286779b18ca6c2fdb",
          "ruleIndex": 29
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "54c6b865dfab4f7f2753eef295d019faf0bd6380545ca87ffbb9a3a31247bbcb"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 46
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `CapturePanic@1`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in CapturePanic@1"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/c4fd969f383f8341d8b01e5f8a9d517e",
          "ruleIndex": 30
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "4017ce1bd3219601e32ab3e5d8cdec89127058231c4fa86c899cf7304aff3792"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setting/setting.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 32
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 41
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 34
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `settingViewHandler`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in settingViewHandler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/5d7a952fd527a76c7cb730e7fc886f2f",
          "ruleIndex": 31
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "839696667b72d973c7c918e651047480aebb37b809bc00abfe91b6a43f28b786"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "user/session/session.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 60
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/setup.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 94
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "setup/setup.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 58
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 63
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 46
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `Self.DeleteSession`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in Self.DeleteSession"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/e8d36a6efd68f7d7cc77a0204c063d7d",
          "ruleIndex": 32
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "3436cd8de30609314969b91fd713fc4e8fc3d716000949165c0c1c67850d4edf"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "user/user.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 107
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/middleware/middleware.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 396
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/log/log.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 396
                }
              }
            }
          ],
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `r` in `Logout`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in Logout"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "2.5"
          },
          "rank": -1,
          "ruleId": "log-forging-attacker/c0bab1ef36ad605d98af9a801f892c04",
          "ruleIndex": 33
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "300f37d08fd9de10a052c9303f4984d7f21a7a55f19965bdbab6a88d66b975b6"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/path-traversal/traversal.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/path-traversal/traversal.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 21
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/home/runner/.cache/go-build/f2/f2bd03d2cac9637b2b083ff09559e7645b17361a98d90be6d3f5a8fca50fe057-d"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 63
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "vulnerability/path-traversal/traversal.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/home/runner/.cache/go-build/f2/f2bd03d2cac9637b2b083ff09559e7645b17361a98d90be6d3f5a8fca50fe057-d"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 219
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "error",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/home/runner/.cache/go-build/f2/f2bd03d2cac9637b2b083ff09559e7645b17361a98d90be6d3f5a8fca50fe057-d"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 219
                }
              }
            }
          ],
          "message": {
            "markdown": "Directory Traversal: Unsafe Unzipping via `r` in `pathTraversalHandler`",
            "text": "Directory Traversal: Unsafe Unzipping via r in pathTraversalHandler"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "high",
            "score": "8"
          },
          "rank": -1,
          "ruleId": "directory-traversal-http-unzip/988bbb0a2d15ca3f55a138573c5851bc",
          "ruleIndex": 34
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "157850a5fb64be21ec0b8f162a9cb62b3dc6b141350f7730788817f866c46936"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/template.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 25
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/header.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 39
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "warning",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/header.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 39
                }
              }
            }
          ],
          "message": {
            "markdown": "Cross-Site Request Forgery: Overly Permissive CORS Policy in `RenderAsJson`",
            "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in RenderAsJson"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "medium",
            "score": "4"
          },
          "rank": -1,
          "ruleId": "cors-allowAll-httpHeader/3589d17ed495f053bc9590c9d1567e0b",
          "ruleIndex": 35
        },
        {
          "fingerprints": {
            "evidenceFingerprint": "a169c5a94c784dd0e89c51875073c7dd8cb371c83f07354e431c536879610e4b"
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "util/template.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 26
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": -1,
                      "importance": "important",
                      "index": -1,
                      "location": {
                        "id": -1,
                        "physicalLocation": {
                          "artifactLocation": {
                            "index": -1,
                            "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/header.go"
                          },
                          "region": {
                            "byteOffset": -1,
                            "charOffset": -1,
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 39
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "kind": "fail",
          "level": "note",
          "locations": [
            {
              "id": -1,
              "physicalLocation": {
                "artifactLocation": {
                  "index": -1,
                  "uri": "/opt/hostedtoolcache/go/1.23.10/x64/src/net/http/header.go"
                },
                "region": {
                  "byteOffset": -1,
                  "charOffset": -1,
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 39
                }
              }
            }
          ],
          "message": {
            "markdown": "Cross-Site Request Forgery: Overly Permissive CORS Policy in `RenderAsJson`",
            "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in RenderAsJson"
          },
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "low",
            "score": "1"
          },
          "rank": -1,
          "ruleId": "cors-allow-credentials/76b0f97745739de0f11473fcc9b8cdfa",
          "ruleIndex": 36
        }
      ],
      "tool": {
        "driver": {
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "fullName": "Qwiet preZero",
          "informationUri": "https://qwiet.ai",
          "language": "en-US",
          "name": "Qwiet preZero",
          "rules": [
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
              "id": "warning-sink-sql/870dab0c4977bb2c66f23bfb553401ab",
              "name": "Sql Injection: Non-Constant Sql Statement In Createprofiletable",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Non-Constant SQL Statement in createProfileTable"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
              "id": "warning-sink-sql/0c86d892065812c87d0782a6ad5cd34d",
              "name": "Sql Injection: Non-Constant Sql Statement In Profile.unsafequerygetdata",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Non-Constant SQL Statement in Profile.UnsafeQueryGetData"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning",
                "rank": -1
              },
              "fullDescription": {
                "text": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability."
              },
              "help": {
                "markdown": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\\/[^\\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\\/[^\\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\\/[^\\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\\/[^\\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\\/[^\\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\\/[^\\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\\/[^\\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\\/[^\\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\\/[^\\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\\/[^\\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/601.html",
              "id": "warning-sink-redirect/db3e076bda55a8c66c3dcd5ab6ec298d",
              "name": "Open Redirect: Non-Constant Url Target Of Http Redirect In Redirect",
              "properties": {
                "precision": "very-high",
                "security-severity": "4",
                "tags": [
                  "CVSS 4",
                  "CWE 601",
                  "OWASP 2021 a01-broken-access-control",
                  "OWASP a01-2021-broken-access-control",
                  "OWASP a1-injection",
                  "Open Redirect",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Open Redirect: Non-Constant URL Target of HTTP Redirect in Redirect"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability."
              },
              "help": {
                "markdown": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability.\n\n# Template Injection\n\nIn web design, a *template* is an HTML-like file interspersed with programmatic instructions to be interpreted by the\nweb-server or JavaScript code in the browser at runtime. A template is a *static* file used to generate HTML by \ninterpolating *dynamic* content retrieved from a database or pulled from HTTP. \n\nA **template injection** vulnerability occurs when the dynamic content is treated by the template engine as code to be \nexecuted rather data to be interpolated. This will allow an attacker to execute malicious code on your server or in a \nvictim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Template Injection in Java\n\nThere are a wide variety of template engines in Java which allow interpolation of data, the most commonly used of which\nis Java Server Pages (JSPs). Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code that uses the Pebble template engine:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine engine = new PebbleEngine.Builder().build();\n        \n        PebbleTemplate compiledTemplate = engine.getLiteralTemplate(\n            \"<div><h1>{{username}}</h1><p>{{\" + field + \"}}</p></div>\"\n        );\n\n        Map<String, Object> user = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        compiledTemplate.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Java application:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine        engine   = new PebbleEngine.Builder().build();\n        PebbleTemplate      template = engine.getTemplate(\"profile.tmp\");\n        Map<String, Object> user     = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        template.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\n:::\n\n:::tab[Angular]\n\n## Template Injection in Angular\n\nAngular apps consist of a hierarchical set of components that encapsulate application logic and state information. Each \ncomponent is rendered in the browser using a template that describes the HTML to output for the given state of the\ncomponent. Angular templates will safely interpolate state using the `{{` and `}}` delimiters, and allow components\nto listen for user interactions using event handlers.\n\nA template is attached to a component using the `@Component` decorator. Templates can be specified with the\n`templateUrl` option, which supplies the relative or absolute path of the corresponding template file:\n\n```typescript\n@Component({\n  selector:    'app-login',\n  templateUrl: './login.component.html',\n  styleUrls:   ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplates can also be provided as inline strings using the `template` option:\n\n```typescript\n@Component({\n  selector: 'app-login',\n  template: '<form (ngSubmit)=\"onSubmit()\">' + \n            '<input type=\"text\"     placeholder=\"Username\" [(ngModel)]=\"username\" />' +\n            '<input type=\"password\" placeholder=\"Password\" [(ngModel)]=\"password\" />' +\n            '<button type=\"submit\">Login</button>' + \n            '</form>',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplate inject vulnerabilities occur in Angular when untrusted input is passed to the `template` option - in \nparticular, when the template string is generated by string concatenation:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>' + (window.location.hash || 'Home') + '</h1>'\n})\nexport class HeaderComponent {}\n```\n\nAvoid dynamically generated templates in this fashion. Instead, load the state into your component, and use Angular's\nbuilt-in interpolation logic to safely escape any untrusted content:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>{{ title }}</h1>'\n})\nexport class HeaderComponent {\n  title = ''  \n    \n  ngOnInit() {\n    this.title = window.location.hash || 'Home';\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Template Injection in C#\n\nDynamic web pages in ASP.NET Core are rendered using Razor templates that allow interpolation of C# code into\nHTML markup. Razor templates are typically defined as `.cshtml` files at compile time, but you can also dynamically\ngenerate Razor templates at runtime. This latter scenario presents some risks, however. Consider the following action:\n\n```csharp\n[HttpGet(\"/users/{username}/{field}\")]\npublic ActionResult Profile(string username, string field)\n{\n    var razor = new RazorEngine();\n    \n    // Dynamically constructing a template through string interpolation is very dangerous!\n    var template = razor.Compile<IdentityUserModel>(@\"\n        <h1>@username</h1>\n        <h2>@\" + field + \"</h2>\" \n    );\n\n    // Load the user details.\n    var user = LoadUser(username);\n\n    // Render the template.\n    var result = template.Run(user);\n\n    // Return the generated HTML.\n    return Content(result, \"text/html\");\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), an \nattacker will be able to inject extra tags and dynamic content into the template.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your Razor templates are statically defined, rather than generated \nby string concatenation at runtime. This is the default behavior in ASP.NET, so it's very simple to implement:\n\n```csharp\npublic class UserController : Controller\n{\n    [HttpGet(\"/users/{username}/{field}\")]\n    public IActionResult Profile(string username, string field)\n    {\n        // Load the user details.\n        var user = LoadUser(username);\n\n        // Set the state to pass to the template, in the case using the dynamic \"ViewBag\" model.\n        ViewBag.UserName     = username\n        ViewBag.ProfileField = user.GetField(field)\n\n        // Render the template at /Views/User/Profile.cshtml\n        return View();\n    }\n}\n```\n\nThe Razor template `/Views/User/Profile.cshtml` will look like an HTML page that renders the model we pass in:\n\n```html\n<html>\n  <body>\n    <h1>@ViewBag.UserName</h1>\n    <h2>@ViewBag.ProfileField</h2>\n  </body>\n</html>\n```\n\nSince the template is defined on disk, and since the names of the HTML tags are *not* dynamically generated, you are\nprotected from template injection.\n\n:::\n\n:::tab[JavaScript]\n\n## Template Injection in JavaScript\n\nThere are a wide variety of template engines in Node.js which allow interpolation of data, as well as language-native\ntemplate literal strings. Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code:\n\n```javascript\n// Load the EJS template engine.\nconst ejs     = require('ejs')\nconst express = require('express')\n\nconst app = express()\n\napp.get('/:username/:field*', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n  const field     = request.params.field\n\n  const template = `\n    <div>\n      <h1> <%= username %> </h1>\n      <p>  <%= ` + field + ` %> </p>\n    </div>`\n\n  response.send(\n    ejs.render(template, user)\n  )\n})\n```\n\nThis function is intended to take a path like `/username/email` and look up the \"email\" field on that particular user. \nHowever, since the second part of the path is concatenated into the template string (notice the `+` characters), a URL\nlike `/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. Performing a \nsimple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure out how to \nrun commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Express application:\n  \n```javascript\n// Load the 'mustache' template engine.\nconst mustache = require('mustache-express')\nconst express  = require('express')\n\nconst app = express()\n\n// Register the .ms extension for mustache template files.\napp.engine('ms', mustache())\n\n// Register the 'mustache' library as our template engine, tell Express to look for\n// templates in the /views directory.\napp.set('view engine', 'ms')\napp.set('views',       '/views')\n\napp.get('/:username/:field', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n\n  // Render the template '/views/user.ms' using the 'mustache' template engine.\n  response.render('user', {\n    username : username,\n    value    : user[request.params.field]\n  })\n})\n\napp.get('/', (request, response) => {\n  response.render('index', {\n    users: Object.values(users)\n  })\n})\n```\n\nYou should prefer a *less* expressive template engine like `mustache.js` over one like `ejs`. The former tokenizes your \ntemplate files and interpolates data, while the latter uses the `eval(...)` function under the hood. Use of `eval(...)` \nfrequently leads to remote code execution vulnerabilities, as illustrated in our first example.\n\n:::\n\n:::tab[Python]\n\n## Template Injection in Python\n\nThere's a wide variety of templating engines in Python. Jinja2 (the default engine for the Flask web-server) is one of\nthe most popular, and allows easy interpolation of data into HTML. Template files can be loaded from disk, or template\nstrings can be constructed dynamically. The latter scenario presents some risks:\n\n```python\nfrom flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  return render_template_string(\"\"\"\n    <div>\n      <h1> {{ username }} </h1>\n      <p>  {{ \"\"\" + field + \"\"\" }} </p>\n    </div>\n  \"\"\", username=username, field=user.get(field, 'No data'))\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  # Since the template is loaded from disk, we can be sure it is statically defined.\n  return render_template('profile.html', \n                         username = username, \n                         field    = user.get(field, 'No data'))\n```\n\n:::\n\n:::tab[React]\n\n## Template Injection in React\n\nMost React developers use JSX to make HTML tags native in JavaScript syntax. JSX makes it easy to dynamically render \npage elements that correspond to data loaded from the server.\n\nProviding all React components are defined in JSX when the code is transpiled to JavaScript during the build process, \nyou are generally safe from template injection attacks. However, React components *can* be generated directly from the \nlow-level APIs at runtime using the `React.createElement(...)` function. If you invoke this method using untrusted \ncontent, you are vulnerable to template injection attacks:\n\n```jsx\nconst tagName     = 'div'\nconst attributes  = { class: 'page-contents' }\nconst textContent = 'Tag contents go here'\n\n/**\n * Dynamically create a React component, in this case:\n * \n *   <div class=\"page-contents\">Tag contents go here</div>\n *   \n * If any of the arguments come from an untrusted source an attacker can inject malicious content.\n */\nReact.createElement(\n  tagName,\n  attributes,\n  textContent\n)\n```\n\nAttackers can also control the attributes and contents of HTML tags if you invoke the `dangerouslySetInnerHTML` \nfunction on a React component:\n\n```jsx\n/**\n * React allows you to write raw HTML from a string, but discourages it - hence the function name\n * \"dangerouslySetInnerHTML(...)\"! If the inputs to this function are taken from an untrusted source\n * you are vulnerable to template injection.\n */\nconst html = { \n  __html: '<div class=\"page-contents\">Tag contents go here</div>' \n}\n<div dangerouslySetInnerHTML={html} />\n```\n\nThe final source of template injection vulnerabilities in React is `href` attributes. If the `href` attribute of a link \nor import statements is dynamically generated from untrusted content, an attacker can inject JavaScript by supplying a \nURL with a `javascript:` prefix:\n\n```jsx\n/**\n * Dynamically setting the `href` of a link can permit cross-site scripting attacks if the  \n * URL is taken from an untrusted source.\n */\nconst link = \"javascript:alert('Oh no')\"\n    \n// An user clicking on this this component will execute the attacker's JavaScript.\nconst button = <a href={link}>Click here</a>\n```\n\n## Mitigation\n\n* Avoid using the `React.createElement(...)` function directly.\n* Don't use the `dangerouslySetInnerHTML` function on React components.\n* Don't dynamically generate `href` attributes from untrusted content.\n\n:::\n\n:::tab[Scala]\n\n## Template Injection in Scala\n\nThe two most popular template engines in Scala are Twirl, which is used by the Play framework, and Scalate, which \nsupports a variety of templates syntaxes. Both are commonly used to generate dynamic HTML by combining static\ntemplate files with dynamic data. The programmatic instructions within these template files can use the full Scala\nsyntax and typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the templates themselves are generated at runtime. Take a look at \nthis vulnerable code that uses the Scalate library to dynamically create and then evaluate a template string:\n\n```scala\ndef details(username : String, field : String) = Action {\n  val template = new StringTemplateSource(\"file.ssp\", \"<html><h1>${username}</h1><h2>${\" + field + \"}</h2></html>\")\n  val output   = new StringWriter()\n  val context  = new DefaultRenderContext(\"\", engine, new PrintWriter(output))\n\n  val user = User.findByUsername(username)\n\n  for ((key, value) <- user) {\n    context.attributes.update(key, value)\n  }\n\n  engine.compile(template).render(context)\n\n  Ok(output.toString).as(\"text/html\")\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by\nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk. In the \nPlay framework, for example, a Twirl template stored at `/app/views/users/profile.scala.html` can be rendered in an\naction with very simply\n\n```scala\n  def profile(username: String, field: String) = Action {\n    User\n      .findByUsername(username)\n      .map { client =>\n        Ok(views.html.users.profile(user, field))\n      }\n      .getOrElse(NotFound)\n  }\n```\n\nThe template `/app/views/users/profile.scala.html` expects a `User` object and a field name:\n\n```html\n@(user: models.User, field: String)\n<html>\n  <h1>@user.username</h1>\n  <h2>@(user.getField(field))</h2>\n</html>\n```\n\nSince the template is defined on disk there is no risk of dynamically executing malicious content passed by an attacker. \nThis will protect your from template injection attacks.\n\n:::\n\n:::tab[Go]\n\n## Template Injection in Go\n\nDynamic HTML is generally generated in Go using the `html/template` package. Template files can be loaded from disk, or \ntemplate strings can be constructed dynamically. The latter scenario presents some risks, as illustrated by the \nfollowing code:\n\n```go\nimport (\n  \"github.com/gorilla/mux\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n)\n\n// Start up a new web server.\nfunc main() {\n  routes := mux.NewRouter()\n  \n  // Add a route to the profile handler.\n  routes.HandleFunc(\"/user/{username}/{field}\", ProfileDataHandler)\n\n  log.Fatal(http.ListenAndServe(\":8000\", routes))\n}\n\n// Render a user's profile.\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  \n  // Load the user referenced in the URL path.\n  user := loadUser(vars[\"username\"])\n\n  // Dynamically generating the template using string concatenation is very dangerous!\n  templateString := `<div>\n                       <h1> {{ .Username }}</h1>\n                       <p>  {{ .` + strings.Title(vars[\"field\"]) + ` }} </p>\n                     </div>`\n\n  // Render the template.\n  template, err := template.New(\"profile\").Parse(templateString)\n\n  if err != nil {\n    http.Error(response, \"Error parsing template\", http.StatusInternalServerError)\n    return\n  }\n\n  // Return the generated HTML.\n  template.Execute(response, user)\n}\n```\n\nThis routing logic is intended to take a path like `/users/username/email` and look up the \"Email\" field on that \nparticular user. However, since the third part of the path is concatenated into the template string - notice the `+` \ncharacters - the `field` parameter will may also get evaluated as a method call on the `User` object. Depending on \nwhich methods are defined on the the `User` object, this potentially gives an attacker a backdoor method of executing\ncode on your web-server.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```go\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  user := loadUser(vars[\"username\"])\n\n  // Load the template from disk.\n  template, err := template.ParseFiles(\"templates/profile.html\")\n\n  // Prepare the user data we wish to render.\n  data := UserData{\n    Username:     user.Username,\n    ProfileField: user.GetField(vars[\"field\"])\n  }\n  \n  template.Execute(response, data)\n}\n```\n\nThe template file `templates/profile.html` will look like this:\n\n```html\n<div>\n  <h1> {{ .Username     }} </h1>\n  <p>  {{ .ProfileField }} </p>\n</div>\n```\n\nSince the template is defined on disk (rather than generated at runtime), an attacker cannot inject dynamic content -\nmeaning you are safe from template injection attacks.\n\n:::\n\n:::tab[PHP]\n\n## Template Injection in PHP\n\nOne of the most commonly used template engines in PHP is Twig. PHP itself has built-in templating capabilities, but more advanced engines like Twig provide more structure and separation of logic from presentation. \n\nIn PHP, a common area of vulnerability is when user input is interpolated directly into the template string. This can lead to template injections if the user input is treated as part of the template logic rather than simple data.\n\nFor example, consider the following vulnerable code snippet:\n\n```php\n<?php\n$username = $_GET['username'];\n$field = $_GET['field'];\n\n$template = \"<div><h1>{{ username }}</h1><p>{{ $field }}</p></div>\";\n\n// Imagine using Twig or another templating engine here\necho $twig->renderString($template, ['username' => $username]);\n?>\n```\n\nIn this code, `$field` is interpolated directly into the template string. A malicious user could craft an input for `field` that would be treated as template logic, leading to unintended code execution.\n\n## Mitigation\n\nTo mitigate template injection attacks in PHP:\n\n1. **Avoid Interpolating User Input Directly**: As a rule, never interpolate user input directly into template strings. Always pass user data as separate context or variables to the template, allowing the engine to handle the data safely.\n\n   ```php\n   $template = \"<div><h1>{{ username }}</h1><p>{{ field }}</p></div>\";\n   echo $twig->renderString($template, ['username' => $username, 'field' => $field]);\n   ```\n\n2. **Escape User Input**: Always escape user input when it's displayed in the template. This will prevent any malicious input from being treated as template code. Many modern templating engines, including Twig, have automatic escaping by default.\n\n3. **Use Built-in Functions**: Instead of creating templates dynamically, utilize built-in functions like `render()` to fetch pre-defined templates and pass data to them. \n\n   ```php\n   echo $twig->render('profile.twig', ['username' => $username, 'field' => $field]);\n   ```\n\n4. **Limit Template Engine Capabilities**: If your template engine allows for it, restrict the functionalities that can be used within templates. For instance, if there's no need for a template to access the filesystem or execute system commands, disable those capabilities.\n\n5. **Update Regularly**: Ensure that your templating engine and all dependencies are regularly updated. This will ensure you have the latest security patches.\n\nBy following these measures, you can significantly reduce the risk of template injection vulnerabilities in your PHP applications.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-79](https://cwe.mitre.org/data/definitions/79.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))**",
                "text": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability.\n\n# Template Injection\n\nIn web design, a *template* is an HTML-like file interspersed with programmatic instructions to be interpreted by the\nweb-server or JavaScript code in the browser at runtime. A template is a *static* file used to generate HTML by \ninterpolating *dynamic* content retrieved from a database or pulled from HTTP. \n\nA **template injection** vulnerability occurs when the dynamic content is treated by the template engine as code to be \nexecuted rather data to be interpolated. This will allow an attacker to execute malicious code on your server or in a \nvictim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Template Injection in Java\n\nThere are a wide variety of template engines in Java which allow interpolation of data, the most commonly used of which\nis Java Server Pages (JSPs). Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code that uses the Pebble template engine:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine engine = new PebbleEngine.Builder().build();\n        \n        PebbleTemplate compiledTemplate = engine.getLiteralTemplate(\n            \"<div><h1>{{username}}</h1><p>{{\" + field + \"}}</p></div>\"\n        );\n\n        Map<String, Object> user = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        compiledTemplate.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Java application:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine        engine   = new PebbleEngine.Builder().build();\n        PebbleTemplate      template = engine.getTemplate(\"profile.tmp\");\n        Map<String, Object> user     = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        template.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\n:::\n\n:::tab[Angular]\n\n## Template Injection in Angular\n\nAngular apps consist of a hierarchical set of components that encapsulate application logic and state information. Each \ncomponent is rendered in the browser using a template that describes the HTML to output for the given state of the\ncomponent. Angular templates will safely interpolate state using the `{{` and `}}` delimiters, and allow components\nto listen for user interactions using event handlers.\n\nA template is attached to a component using the `@Component` decorator. Templates can be specified with the\n`templateUrl` option, which supplies the relative or absolute path of the corresponding template file:\n\n```typescript\n@Component({\n  selector:    'app-login',\n  templateUrl: './login.component.html',\n  styleUrls:   ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplates can also be provided as inline strings using the `template` option:\n\n```typescript\n@Component({\n  selector: 'app-login',\n  template: '<form (ngSubmit)=\"onSubmit()\">' + \n            '<input type=\"text\"     placeholder=\"Username\" [(ngModel)]=\"username\" />' +\n            '<input type=\"password\" placeholder=\"Password\" [(ngModel)]=\"password\" />' +\n            '<button type=\"submit\">Login</button>' + \n            '</form>',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplate inject vulnerabilities occur in Angular when untrusted input is passed to the `template` option - in \nparticular, when the template string is generated by string concatenation:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>' + (window.location.hash || 'Home') + '</h1>'\n})\nexport class HeaderComponent {}\n```\n\nAvoid dynamically generated templates in this fashion. Instead, load the state into your component, and use Angular's\nbuilt-in interpolation logic to safely escape any untrusted content:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>{{ title }}</h1>'\n})\nexport class HeaderComponent {\n  title = ''  \n    \n  ngOnInit() {\n    this.title = window.location.hash || 'Home';\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Template Injection in C#\n\nDynamic web pages in ASP.NET Core are rendered using Razor templates that allow interpolation of C# code into\nHTML markup. Razor templates are typically defined as `.cshtml` files at compile time, but you can also dynamically\ngenerate Razor templates at runtime. This latter scenario presents some risks, however. Consider the following action:\n\n```csharp\n[HttpGet(\"/users/{username}/{field}\")]\npublic ActionResult Profile(string username, string field)\n{\n    var razor = new RazorEngine();\n    \n    // Dynamically constructing a template through string interpolation is very dangerous!\n    var template = razor.Compile<IdentityUserModel>(@\"\n        <h1>@username</h1>\n        <h2>@\" + field + \"</h2>\" \n    );\n\n    // Load the user details.\n    var user = LoadUser(username);\n\n    // Render the template.\n    var result = template.Run(user);\n\n    // Return the generated HTML.\n    return Content(result, \"text/html\");\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), an \nattacker will be able to inject extra tags and dynamic content into the template.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your Razor templates are statically defined, rather than generated \nby string concatenation at runtime. This is the default behavior in ASP.NET, so it's very simple to implement:\n\n```csharp\npublic class UserController : Controller\n{\n    [HttpGet(\"/users/{username}/{field}\")]\n    public IActionResult Profile(string username, string field)\n    {\n        // Load the user details.\n        var user = LoadUser(username);\n\n        // Set the state to pass to the template, in the case using the dynamic \"ViewBag\" model.\n        ViewBag.UserName     = username\n        ViewBag.ProfileField = user.GetField(field)\n\n        // Render the template at /Views/User/Profile.cshtml\n        return View();\n    }\n}\n```\n\nThe Razor template `/Views/User/Profile.cshtml` will look like an HTML page that renders the model we pass in:\n\n```html\n<html>\n  <body>\n    <h1>@ViewBag.UserName</h1>\n    <h2>@ViewBag.ProfileField</h2>\n  </body>\n</html>\n```\n\nSince the template is defined on disk, and since the names of the HTML tags are *not* dynamically generated, you are\nprotected from template injection.\n\n:::\n\n:::tab[JavaScript]\n\n## Template Injection in JavaScript\n\nThere are a wide variety of template engines in Node.js which allow interpolation of data, as well as language-native\ntemplate literal strings. Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code:\n\n```javascript\n// Load the EJS template engine.\nconst ejs     = require('ejs')\nconst express = require('express')\n\nconst app = express()\n\napp.get('/:username/:field*', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n  const field     = request.params.field\n\n  const template = `\n    <div>\n      <h1> <%= username %> </h1>\n      <p>  <%= ` + field + ` %> </p>\n    </div>`\n\n  response.send(\n    ejs.render(template, user)\n  )\n})\n```\n\nThis function is intended to take a path like `/username/email` and look up the \"email\" field on that particular user. \nHowever, since the second part of the path is concatenated into the template string (notice the `+` characters), a URL\nlike `/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. Performing a \nsimple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure out how to \nrun commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Express application:\n  \n```javascript\n// Load the 'mustache' template engine.\nconst mustache = require('mustache-express')\nconst express  = require('express')\n\nconst app = express()\n\n// Register the .ms extension for mustache template files.\napp.engine('ms', mustache())\n\n// Register the 'mustache' library as our template engine, tell Express to look for\n// templates in the /views directory.\napp.set('view engine', 'ms')\napp.set('views',       '/views')\n\napp.get('/:username/:field', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n\n  // Render the template '/views/user.ms' using the 'mustache' template engine.\n  response.render('user', {\n    username : username,\n    value    : user[request.params.field]\n  })\n})\n\napp.get('/', (request, response) => {\n  response.render('index', {\n    users: Object.values(users)\n  })\n})\n```\n\nYou should prefer a *less* expressive template engine like `mustache.js` over one like `ejs`. The former tokenizes your \ntemplate files and interpolates data, while the latter uses the `eval(...)` function under the hood. Use of `eval(...)` \nfrequently leads to remote code execution vulnerabilities, as illustrated in our first example.\n\n:::\n\n:::tab[Python]\n\n## Template Injection in Python\n\nThere's a wide variety of templating engines in Python. Jinja2 (the default engine for the Flask web-server) is one of\nthe most popular, and allows easy interpolation of data into HTML. Template files can be loaded from disk, or template\nstrings can be constructed dynamically. The latter scenario presents some risks:\n\n```python\nfrom flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  return render_template_string(\"\"\"\n    <div>\n      <h1> {{ username }} </h1>\n      <p>  {{ \"\"\" + field + \"\"\" }} </p>\n    </div>\n  \"\"\", username=username, field=user.get(field, 'No data'))\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  # Since the template is loaded from disk, we can be sure it is statically defined.\n  return render_template('profile.html', \n                         username = username, \n                         field    = user.get(field, 'No data'))\n```\n\n:::\n\n:::tab[React]\n\n## Template Injection in React\n\nMost React developers use JSX to make HTML tags native in JavaScript syntax. JSX makes it easy to dynamically render \npage elements that correspond to data loaded from the server.\n\nProviding all React components are defined in JSX when the code is transpiled to JavaScript during the build process, \nyou are generally safe from template injection attacks. However, React components *can* be generated directly from the \nlow-level APIs at runtime using the `React.createElement(...)` function. If you invoke this method using untrusted \ncontent, you are vulnerable to template injection attacks:\n\n```jsx\nconst tagName     = 'div'\nconst attributes  = { class: 'page-contents' }\nconst textContent = 'Tag contents go here'\n\n/**\n * Dynamically create a React component, in this case:\n * \n *   <div class=\"page-contents\">Tag contents go here</div>\n *   \n * If any of the arguments come from an untrusted source an attacker can inject malicious content.\n */\nReact.createElement(\n  tagName,\n  attributes,\n  textContent\n)\n```\n\nAttackers can also control the attributes and contents of HTML tags if you invoke the `dangerouslySetInnerHTML` \nfunction on a React component:\n\n```jsx\n/**\n * React allows you to write raw HTML from a string, but discourages it - hence the function name\n * \"dangerouslySetInnerHTML(...)\"! If the inputs to this function are taken from an untrusted source\n * you are vulnerable to template injection.\n */\nconst html = { \n  __html: '<div class=\"page-contents\">Tag contents go here</div>' \n}\n<div dangerouslySetInnerHTML={html} />\n```\n\nThe final source of template injection vulnerabilities in React is `href` attributes. If the `href` attribute of a link \nor import statements is dynamically generated from untrusted content, an attacker can inject JavaScript by supplying a \nURL with a `javascript:` prefix:\n\n```jsx\n/**\n * Dynamically setting the `href` of a link can permit cross-site scripting attacks if the  \n * URL is taken from an untrusted source.\n */\nconst link = \"javascript:alert('Oh no')\"\n    \n// An user clicking on this this component will execute the attacker's JavaScript.\nconst button = <a href={link}>Click here</a>\n```\n\n## Mitigation\n\n* Avoid using the `React.createElement(...)` function directly.\n* Don't use the `dangerouslySetInnerHTML` function on React components.\n* Don't dynamically generate `href` attributes from untrusted content.\n\n:::\n\n:::tab[Scala]\n\n## Template Injection in Scala\n\nThe two most popular template engines in Scala are Twirl, which is used by the Play framework, and Scalate, which \nsupports a variety of templates syntaxes. Both are commonly used to generate dynamic HTML by combining static\ntemplate files with dynamic data. The programmatic instructions within these template files can use the full Scala\nsyntax and typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the templates themselves are generated at runtime. Take a look at \nthis vulnerable code that uses the Scalate library to dynamically create and then evaluate a template string:\n\n```scala\ndef details(username : String, field : String) = Action {\n  val template = new StringTemplateSource(\"file.ssp\", \"<html><h1>${username}</h1><h2>${\" + field + \"}</h2></html>\")\n  val output   = new StringWriter()\n  val context  = new DefaultRenderContext(\"\", engine, new PrintWriter(output))\n\n  val user = User.findByUsername(username)\n\n  for ((key, value) <- user) {\n    context.attributes.update(key, value)\n  }\n\n  engine.compile(template).render(context)\n\n  Ok(output.toString).as(\"text/html\")\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by\nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk. In the \nPlay framework, for example, a Twirl template stored at `/app/views/users/profile.scala.html` can be rendered in an\naction with very simply\n\n```scala\n  def profile(username: String, field: String) = Action {\n    User\n      .findByUsername(username)\n      .map { client =>\n        Ok(views.html.users.profile(user, field))\n      }\n      .getOrElse(NotFound)\n  }\n```\n\nThe template `/app/views/users/profile.scala.html` expects a `User` object and a field name:\n\n```html\n@(user: models.User, field: String)\n<html>\n  <h1>@user.username</h1>\n  <h2>@(user.getField(field))</h2>\n</html>\n```\n\nSince the template is defined on disk there is no risk of dynamically executing malicious content passed by an attacker. \nThis will protect your from template injection attacks.\n\n:::\n\n:::tab[Go]\n\n## Template Injection in Go\n\nDynamic HTML is generally generated in Go using the `html/template` package. Template files can be loaded from disk, or \ntemplate strings can be constructed dynamically. The latter scenario presents some risks, as illustrated by the \nfollowing code:\n\n```go\nimport (\n  \"github.com/gorilla/mux\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n)\n\n// Start up a new web server.\nfunc main() {\n  routes := mux.NewRouter()\n  \n  // Add a route to the profile handler.\n  routes.HandleFunc(\"/user/{username}/{field}\", ProfileDataHandler)\n\n  log.Fatal(http.ListenAndServe(\":8000\", routes))\n}\n\n// Render a user's profile.\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  \n  // Load the user referenced in the URL path.\n  user := loadUser(vars[\"username\"])\n\n  // Dynamically generating the template using string concatenation is very dangerous!\n  templateString := `<div>\n                       <h1> {{ .Username }}</h1>\n                       <p>  {{ .` + strings.Title(vars[\"field\"]) + ` }} </p>\n                     </div>`\n\n  // Render the template.\n  template, err := template.New(\"profile\").Parse(templateString)\n\n  if err != nil {\n    http.Error(response, \"Error parsing template\", http.StatusInternalServerError)\n    return\n  }\n\n  // Return the generated HTML.\n  template.Execute(response, user)\n}\n```\n\nThis routing logic is intended to take a path like `/users/username/email` and look up the \"Email\" field on that \nparticular user. However, since the third part of the path is concatenated into the template string - notice the `+` \ncharacters - the `field` parameter will may also get evaluated as a method call on the `User` object. Depending on \nwhich methods are defined on the the `User` object, this potentially gives an attacker a backdoor method of executing\ncode on your web-server.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```go\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  user := loadUser(vars[\"username\"])\n\n  // Load the template from disk.\n  template, err := template.ParseFiles(\"templates/profile.html\")\n\n  // Prepare the user data we wish to render.\n  data := UserData{\n    Username:     user.Username,\n    ProfileField: user.GetField(vars[\"field\"])\n  }\n  \n  template.Execute(response, data)\n}\n```\n\nThe template file `templates/profile.html` will look like this:\n\n```html\n<div>\n  <h1> {{ .Username     }} </h1>\n  <p>  {{ .ProfileField }} </p>\n</div>\n```\n\nSince the template is defined on disk (rather than generated at runtime), an attacker cannot inject dynamic content -\nmeaning you are safe from template injection attacks.\n\n:::\n\n:::tab[PHP]\n\n## Template Injection in PHP\n\nOne of the most commonly used template engines in PHP is Twig. PHP itself has built-in templating capabilities, but more advanced engines like Twig provide more structure and separation of logic from presentation. \n\nIn PHP, a common area of vulnerability is when user input is interpolated directly into the template string. This can lead to template injections if the user input is treated as part of the template logic rather than simple data.\n\nFor example, consider the following vulnerable code snippet:\n\n```php\n<?php\n$username = $_GET['username'];\n$field = $_GET['field'];\n\n$template = \"<div><h1>{{ username }}</h1><p>{{ $field }}</p></div>\";\n\n// Imagine using Twig or another templating engine here\necho $twig->renderString($template, ['username' => $username]);\n?>\n```\n\nIn this code, `$field` is interpolated directly into the template string. A malicious user could craft an input for `field` that would be treated as template logic, leading to unintended code execution.\n\n## Mitigation\n\nTo mitigate template injection attacks in PHP:\n\n1. **Avoid Interpolating User Input Directly**: As a rule, never interpolate user input directly into template strings. Always pass user data as separate context or variables to the template, allowing the engine to handle the data safely.\n\n   ```php\n   $template = \"<div><h1>{{ username }}</h1><p>{{ field }}</p></div>\";\n   echo $twig->renderString($template, ['username' => $username, 'field' => $field]);\n   ```\n\n2. **Escape User Input**: Always escape user input when it's displayed in the template. This will prevent any malicious input from being treated as template code. Many modern templating engines, including Twig, have automatic escaping by default.\n\n3. **Use Built-in Functions**: Instead of creating templates dynamically, utilize built-in functions like `render()` to fetch pre-defined templates and pass data to them. \n\n   ```php\n   echo $twig->render('profile.twig', ['username' => $username, 'field' => $field]);\n   ```\n\n4. **Limit Template Engine Capabilities**: If your template engine allows for it, restrict the functionalities that can be used within templates. For instance, if there's no need for a template to access the filesystem or execute system commands, disable those capabilities.\n\n5. **Update Regularly**: Ensure that your templating engine and all dependencies are regularly updated. This will ensure you have the latest security patches.\n\nBy following these measures, you can significantly reduce the risk of template injection vulnerabilities in your PHP applications.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-79](https://cwe.mitre.org/data/definitions/79.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a7-Cross-Site_Scripting_(XSS)",
              "id": "xss-to-html-template/a4027996d3dd4fee4d2747deff915dba",
              "name": "Template Injection: Http Data Used In Html Template Via R In Xss2handler",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 79",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a7-xss",
                  "Template Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Template Injection: HTTP Data Used in HTML Template via r in xss2Handler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/5a32131deea445fc16b1b1fde29bd1c6",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Indexhandler",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in indexHandler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/5d7a952fd527a76c7cb730e7fc886f2f",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Settingviewhandler",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in settingViewHandler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The Access-Control-Allow-Credentials (CORS) header is set to true, allowing cookies and credentials to be sent with."
              },
              "help": {
                "markdown": "The Access-Control-Allow-Credentials (CORS) header is set to true, allowing cookies and credentials to be sent with\ncross-site requests from third-party web sites. This opts out of standard protections against Cross-Site Request Forgery attacks.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)",
                "text": "The Access-Control-Allow-Credentials (CORS) header is set to true, allowing cookies and credentials to be sent with\ncross-site requests from third-party web sites. This opts out of standard protections against Cross-Site Request Forgery attacks.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a6-Security_Misconfiguration",
              "id": "cors-allow-credentials/76b0f97745739de0f11473fcc9b8cdfa",
              "name": "Cross-Site Request Forgery: Overly Permissive Cors Policy In Renderasjson",
              "properties": {
                "precision": "very-high",
                "security-severity": "1",
                "tags": [
                  "CVSS 1",
                  "CWE 942",
                  "Cross-Site Request Forgery",
                  "OWASP 2021 a05-security-misconfiguration",
                  "OWASP a05-2021-security-misconfiguration",
                  "OWASP a6-security-misconfiguration",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in RenderAsJson"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "unarr.go in go-unarr (aka Go bindings for unarr) 0.1.1 allows Directory Traversal via ../ in a pathname within a TAR archive."
              },
              "help": {
                "markdown": "unarr.go in go-unarr (aka Go bindings for unarr) 0.1.1 allows Directory Traversal via ../ in a pathname within a TAR archive.",
                "text": "unarr.go in go-unarr (aka Go bindings for unarr) 0.1.1 allows Directory Traversal via ../ in a pathname within a TAR archive."
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/22.html",
              "id": "oss_vuln/5e8b09a9dd7eb14a3c04b026569974ab",
              "name": "Pkg:golang/Github.com/Gen2brain/Go-Unarr@V0.1.1",
              "properties": {
                "precision": "very-high",
                "security-severity": "9.8",
                "tags": [
                  "CVE-2021-38197",
                  "CVSS 9.8",
                  "CWE 22",
                  "EPSS 0.01",
                  "Exploitable",
                  "Unreachable",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "pkg:golang/github.com/gen2brain/go-unarr@v0.1.1"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability."
              },
              "help": {
                "markdown": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability.\n\n# Template Injection\n\nIn web design, a *template* is an HTML-like file interspersed with programmatic instructions to be interpreted by the\nweb-server or JavaScript code in the browser at runtime. A template is a *static* file used to generate HTML by \ninterpolating *dynamic* content retrieved from a database or pulled from HTTP. \n\nA **template injection** vulnerability occurs when the dynamic content is treated by the template engine as code to be \nexecuted rather data to be interpolated. This will allow an attacker to execute malicious code on your server or in a \nvictim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Template Injection in Java\n\nThere are a wide variety of template engines in Java which allow interpolation of data, the most commonly used of which\nis Java Server Pages (JSPs). Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code that uses the Pebble template engine:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine engine = new PebbleEngine.Builder().build();\n        \n        PebbleTemplate compiledTemplate = engine.getLiteralTemplate(\n            \"<div><h1>{{username}}</h1><p>{{\" + field + \"}}</p></div>\"\n        );\n\n        Map<String, Object> user = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        compiledTemplate.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Java application:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine        engine   = new PebbleEngine.Builder().build();\n        PebbleTemplate      template = engine.getTemplate(\"profile.tmp\");\n        Map<String, Object> user     = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        template.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\n:::\n\n:::tab[Angular]\n\n## Template Injection in Angular\n\nAngular apps consist of a hierarchical set of components that encapsulate application logic and state information. Each \ncomponent is rendered in the browser using a template that describes the HTML to output for the given state of the\ncomponent. Angular templates will safely interpolate state using the `{{` and `}}` delimiters, and allow components\nto listen for user interactions using event handlers.\n\nA template is attached to a component using the `@Component` decorator. Templates can be specified with the\n`templateUrl` option, which supplies the relative or absolute path of the corresponding template file:\n\n```typescript\n@Component({\n  selector:    'app-login',\n  templateUrl: './login.component.html',\n  styleUrls:   ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplates can also be provided as inline strings using the `template` option:\n\n```typescript\n@Component({\n  selector: 'app-login',\n  template: '<form (ngSubmit)=\"onSubmit()\">' + \n            '<input type=\"text\"     placeholder=\"Username\" [(ngModel)]=\"username\" />' +\n            '<input type=\"password\" placeholder=\"Password\" [(ngModel)]=\"password\" />' +\n            '<button type=\"submit\">Login</button>' + \n            '</form>',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplate inject vulnerabilities occur in Angular when untrusted input is passed to the `template` option - in \nparticular, when the template string is generated by string concatenation:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>' + (window.location.hash || 'Home') + '</h1>'\n})\nexport class HeaderComponent {}\n```\n\nAvoid dynamically generated templates in this fashion. Instead, load the state into your component, and use Angular's\nbuilt-in interpolation logic to safely escape any untrusted content:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>{{ title }}</h1>'\n})\nexport class HeaderComponent {\n  title = ''  \n    \n  ngOnInit() {\n    this.title = window.location.hash || 'Home';\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Template Injection in C#\n\nDynamic web pages in ASP.NET Core are rendered using Razor templates that allow interpolation of C# code into\nHTML markup. Razor templates are typically defined as `.cshtml` files at compile time, but you can also dynamically\ngenerate Razor templates at runtime. This latter scenario presents some risks, however. Consider the following action:\n\n```csharp\n[HttpGet(\"/users/{username}/{field}\")]\npublic ActionResult Profile(string username, string field)\n{\n    var razor = new RazorEngine();\n    \n    // Dynamically constructing a template through string interpolation is very dangerous!\n    var template = razor.Compile<IdentityUserModel>(@\"\n        <h1>@username</h1>\n        <h2>@\" + field + \"</h2>\" \n    );\n\n    // Load the user details.\n    var user = LoadUser(username);\n\n    // Render the template.\n    var result = template.Run(user);\n\n    // Return the generated HTML.\n    return Content(result, \"text/html\");\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), an \nattacker will be able to inject extra tags and dynamic content into the template.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your Razor templates are statically defined, rather than generated \nby string concatenation at runtime. This is the default behavior in ASP.NET, so it's very simple to implement:\n\n```csharp\npublic class UserController : Controller\n{\n    [HttpGet(\"/users/{username}/{field}\")]\n    public IActionResult Profile(string username, string field)\n    {\n        // Load the user details.\n        var user = LoadUser(username);\n\n        // Set the state to pass to the template, in the case using the dynamic \"ViewBag\" model.\n        ViewBag.UserName     = username\n        ViewBag.ProfileField = user.GetField(field)\n\n        // Render the template at /Views/User/Profile.cshtml\n        return View();\n    }\n}\n```\n\nThe Razor template `/Views/User/Profile.cshtml` will look like an HTML page that renders the model we pass in:\n\n```html\n<html>\n  <body>\n    <h1>@ViewBag.UserName</h1>\n    <h2>@ViewBag.ProfileField</h2>\n  </body>\n</html>\n```\n\nSince the template is defined on disk, and since the names of the HTML tags are *not* dynamically generated, you are\nprotected from template injection.\n\n:::\n\n:::tab[JavaScript]\n\n## Template Injection in JavaScript\n\nThere are a wide variety of template engines in Node.js which allow interpolation of data, as well as language-native\ntemplate literal strings. Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code:\n\n```javascript\n// Load the EJS template engine.\nconst ejs     = require('ejs')\nconst express = require('express')\n\nconst app = express()\n\napp.get('/:username/:field*', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n  const field     = request.params.field\n\n  const template = `\n    <div>\n      <h1> <%= username %> </h1>\n      <p>  <%= ` + field + ` %> </p>\n    </div>`\n\n  response.send(\n    ejs.render(template, user)\n  )\n})\n```\n\nThis function is intended to take a path like `/username/email` and look up the \"email\" field on that particular user. \nHowever, since the second part of the path is concatenated into the template string (notice the `+` characters), a URL\nlike `/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. Performing a \nsimple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure out how to \nrun commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Express application:\n  \n```javascript\n// Load the 'mustache' template engine.\nconst mustache = require('mustache-express')\nconst express  = require('express')\n\nconst app = express()\n\n// Register the .ms extension for mustache template files.\napp.engine('ms', mustache())\n\n// Register the 'mustache' library as our template engine, tell Express to look for\n// templates in the /views directory.\napp.set('view engine', 'ms')\napp.set('views',       '/views')\n\napp.get('/:username/:field', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n\n  // Render the template '/views/user.ms' using the 'mustache' template engine.\n  response.render('user', {\n    username : username,\n    value    : user[request.params.field]\n  })\n})\n\napp.get('/', (request, response) => {\n  response.render('index', {\n    users: Object.values(users)\n  })\n})\n```\n\nYou should prefer a *less* expressive template engine like `mustache.js` over one like `ejs`. The former tokenizes your \ntemplate files and interpolates data, while the latter uses the `eval(...)` function under the hood. Use of `eval(...)` \nfrequently leads to remote code execution vulnerabilities, as illustrated in our first example.\n\n:::\n\n:::tab[Python]\n\n## Template Injection in Python\n\nThere's a wide variety of templating engines in Python. Jinja2 (the default engine for the Flask web-server) is one of\nthe most popular, and allows easy interpolation of data into HTML. Template files can be loaded from disk, or template\nstrings can be constructed dynamically. The latter scenario presents some risks:\n\n```python\nfrom flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  return render_template_string(\"\"\"\n    <div>\n      <h1> {{ username }} </h1>\n      <p>  {{ \"\"\" + field + \"\"\" }} </p>\n    </div>\n  \"\"\", username=username, field=user.get(field, 'No data'))\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  # Since the template is loaded from disk, we can be sure it is statically defined.\n  return render_template('profile.html', \n                         username = username, \n                         field    = user.get(field, 'No data'))\n```\n\n:::\n\n:::tab[React]\n\n## Template Injection in React\n\nMost React developers use JSX to make HTML tags native in JavaScript syntax. JSX makes it easy to dynamically render \npage elements that correspond to data loaded from the server.\n\nProviding all React components are defined in JSX when the code is transpiled to JavaScript during the build process, \nyou are generally safe from template injection attacks. However, React components *can* be generated directly from the \nlow-level APIs at runtime using the `React.createElement(...)` function. If you invoke this method using untrusted \ncontent, you are vulnerable to template injection attacks:\n\n```jsx\nconst tagName     = 'div'\nconst attributes  = { class: 'page-contents' }\nconst textContent = 'Tag contents go here'\n\n/**\n * Dynamically create a React component, in this case:\n * \n *   <div class=\"page-contents\">Tag contents go here</div>\n *   \n * If any of the arguments come from an untrusted source an attacker can inject malicious content.\n */\nReact.createElement(\n  tagName,\n  attributes,\n  textContent\n)\n```\n\nAttackers can also control the attributes and contents of HTML tags if you invoke the `dangerouslySetInnerHTML` \nfunction on a React component:\n\n```jsx\n/**\n * React allows you to write raw HTML from a string, but discourages it - hence the function name\n * \"dangerouslySetInnerHTML(...)\"! If the inputs to this function are taken from an untrusted source\n * you are vulnerable to template injection.\n */\nconst html = { \n  __html: '<div class=\"page-contents\">Tag contents go here</div>' \n}\n<div dangerouslySetInnerHTML={html} />\n```\n\nThe final source of template injection vulnerabilities in React is `href` attributes. If the `href` attribute of a link \nor import statements is dynamically generated from untrusted content, an attacker can inject JavaScript by supplying a \nURL with a `javascript:` prefix:\n\n```jsx\n/**\n * Dynamically setting the `href` of a link can permit cross-site scripting attacks if the  \n * URL is taken from an untrusted source.\n */\nconst link = \"javascript:alert('Oh no')\"\n    \n// An user clicking on this this component will execute the attacker's JavaScript.\nconst button = <a href={link}>Click here</a>\n```\n\n## Mitigation\n\n* Avoid using the `React.createElement(...)` function directly.\n* Don't use the `dangerouslySetInnerHTML` function on React components.\n* Don't dynamically generate `href` attributes from untrusted content.\n\n:::\n\n:::tab[Scala]\n\n## Template Injection in Scala\n\nThe two most popular template engines in Scala are Twirl, which is used by the Play framework, and Scalate, which \nsupports a variety of templates syntaxes. Both are commonly used to generate dynamic HTML by combining static\ntemplate files with dynamic data. The programmatic instructions within these template files can use the full Scala\nsyntax and typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the templates themselves are generated at runtime. Take a look at \nthis vulnerable code that uses the Scalate library to dynamically create and then evaluate a template string:\n\n```scala\ndef details(username : String, field : String) = Action {\n  val template = new StringTemplateSource(\"file.ssp\", \"<html><h1>${username}</h1><h2>${\" + field + \"}</h2></html>\")\n  val output   = new StringWriter()\n  val context  = new DefaultRenderContext(\"\", engine, new PrintWriter(output))\n\n  val user = User.findByUsername(username)\n\n  for ((key, value) <- user) {\n    context.attributes.update(key, value)\n  }\n\n  engine.compile(template).render(context)\n\n  Ok(output.toString).as(\"text/html\")\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by\nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk. In the \nPlay framework, for example, a Twirl template stored at `/app/views/users/profile.scala.html` can be rendered in an\naction with very simply\n\n```scala\n  def profile(username: String, field: String) = Action {\n    User\n      .findByUsername(username)\n      .map { client =>\n        Ok(views.html.users.profile(user, field))\n      }\n      .getOrElse(NotFound)\n  }\n```\n\nThe template `/app/views/users/profile.scala.html` expects a `User` object and a field name:\n\n```html\n@(user: models.User, field: String)\n<html>\n  <h1>@user.username</h1>\n  <h2>@(user.getField(field))</h2>\n</html>\n```\n\nSince the template is defined on disk there is no risk of dynamically executing malicious content passed by an attacker. \nThis will protect your from template injection attacks.\n\n:::\n\n:::tab[Go]\n\n## Template Injection in Go\n\nDynamic HTML is generally generated in Go using the `html/template` package. Template files can be loaded from disk, or \ntemplate strings can be constructed dynamically. The latter scenario presents some risks, as illustrated by the \nfollowing code:\n\n```go\nimport (\n  \"github.com/gorilla/mux\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n)\n\n// Start up a new web server.\nfunc main() {\n  routes := mux.NewRouter()\n  \n  // Add a route to the profile handler.\n  routes.HandleFunc(\"/user/{username}/{field}\", ProfileDataHandler)\n\n  log.Fatal(http.ListenAndServe(\":8000\", routes))\n}\n\n// Render a user's profile.\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  \n  // Load the user referenced in the URL path.\n  user := loadUser(vars[\"username\"])\n\n  // Dynamically generating the template using string concatenation is very dangerous!\n  templateString := `<div>\n                       <h1> {{ .Username }}</h1>\n                       <p>  {{ .` + strings.Title(vars[\"field\"]) + ` }} </p>\n                     </div>`\n\n  // Render the template.\n  template, err := template.New(\"profile\").Parse(templateString)\n\n  if err != nil {\n    http.Error(response, \"Error parsing template\", http.StatusInternalServerError)\n    return\n  }\n\n  // Return the generated HTML.\n  template.Execute(response, user)\n}\n```\n\nThis routing logic is intended to take a path like `/users/username/email` and look up the \"Email\" field on that \nparticular user. However, since the third part of the path is concatenated into the template string - notice the `+` \ncharacters - the `field` parameter will may also get evaluated as a method call on the `User` object. Depending on \nwhich methods are defined on the the `User` object, this potentially gives an attacker a backdoor method of executing\ncode on your web-server.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```go\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  user := loadUser(vars[\"username\"])\n\n  // Load the template from disk.\n  template, err := template.ParseFiles(\"templates/profile.html\")\n\n  // Prepare the user data we wish to render.\n  data := UserData{\n    Username:     user.Username,\n    ProfileField: user.GetField(vars[\"field\"])\n  }\n  \n  template.Execute(response, data)\n}\n```\n\nThe template file `templates/profile.html` will look like this:\n\n```html\n<div>\n  <h1> {{ .Username     }} </h1>\n  <p>  {{ .ProfileField }} </p>\n</div>\n```\n\nSince the template is defined on disk (rather than generated at runtime), an attacker cannot inject dynamic content -\nmeaning you are safe from template injection attacks.\n\n:::\n\n:::tab[PHP]\n\n## Template Injection in PHP\n\nOne of the most commonly used template engines in PHP is Twig. PHP itself has built-in templating capabilities, but more advanced engines like Twig provide more structure and separation of logic from presentation. \n\nIn PHP, a common area of vulnerability is when user input is interpolated directly into the template string. This can lead to template injections if the user input is treated as part of the template logic rather than simple data.\n\nFor example, consider the following vulnerable code snippet:\n\n```php\n<?php\n$username = $_GET['username'];\n$field = $_GET['field'];\n\n$template = \"<div><h1>{{ username }}</h1><p>{{ $field }}</p></div>\";\n\n// Imagine using Twig or another templating engine here\necho $twig->renderString($template, ['username' => $username]);\n?>\n```\n\nIn this code, `$field` is interpolated directly into the template string. A malicious user could craft an input for `field` that would be treated as template logic, leading to unintended code execution.\n\n## Mitigation\n\nTo mitigate template injection attacks in PHP:\n\n1. **Avoid Interpolating User Input Directly**: As a rule, never interpolate user input directly into template strings. Always pass user data as separate context or variables to the template, allowing the engine to handle the data safely.\n\n   ```php\n   $template = \"<div><h1>{{ username }}</h1><p>{{ field }}</p></div>\";\n   echo $twig->renderString($template, ['username' => $username, 'field' => $field]);\n   ```\n\n2. **Escape User Input**: Always escape user input when it's displayed in the template. This will prevent any malicious input from being treated as template code. Many modern templating engines, including Twig, have automatic escaping by default.\n\n3. **Use Built-in Functions**: Instead of creating templates dynamically, utilize built-in functions like `render()` to fetch pre-defined templates and pass data to them. \n\n   ```php\n   echo $twig->render('profile.twig', ['username' => $username, 'field' => $field]);\n   ```\n\n4. **Limit Template Engine Capabilities**: If your template engine allows for it, restrict the functionalities that can be used within templates. For instance, if there's no need for a template to access the filesystem or execute system commands, disable those capabilities.\n\n5. **Update Regularly**: Ensure that your templating engine and all dependencies are regularly updated. This will ensure you have the latest security patches.\n\nBy following these measures, you can significantly reduce the risk of template injection vulnerabilities in your PHP applications.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-79](https://cwe.mitre.org/data/definitions/79.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))**",
                "text": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability.\n\n# Template Injection\n\nIn web design, a *template* is an HTML-like file interspersed with programmatic instructions to be interpreted by the\nweb-server or JavaScript code in the browser at runtime. A template is a *static* file used to generate HTML by \ninterpolating *dynamic* content retrieved from a database or pulled from HTTP. \n\nA **template injection** vulnerability occurs when the dynamic content is treated by the template engine as code to be \nexecuted rather data to be interpolated. This will allow an attacker to execute malicious code on your server or in a \nvictim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Template Injection in Java\n\nThere are a wide variety of template engines in Java which allow interpolation of data, the most commonly used of which\nis Java Server Pages (JSPs). Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code that uses the Pebble template engine:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine engine = new PebbleEngine.Builder().build();\n        \n        PebbleTemplate compiledTemplate = engine.getLiteralTemplate(\n            \"<div><h1>{{username}}</h1><p>{{\" + field + \"}}</p></div>\"\n        );\n\n        Map<String, Object> user = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        compiledTemplate.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Java application:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine        engine   = new PebbleEngine.Builder().build();\n        PebbleTemplate      template = engine.getTemplate(\"profile.tmp\");\n        Map<String, Object> user     = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        template.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\n:::\n\n:::tab[Angular]\n\n## Template Injection in Angular\n\nAngular apps consist of a hierarchical set of components that encapsulate application logic and state information. Each \ncomponent is rendered in the browser using a template that describes the HTML to output for the given state of the\ncomponent. Angular templates will safely interpolate state using the `{{` and `}}` delimiters, and allow components\nto listen for user interactions using event handlers.\n\nA template is attached to a component using the `@Component` decorator. Templates can be specified with the\n`templateUrl` option, which supplies the relative or absolute path of the corresponding template file:\n\n```typescript\n@Component({\n  selector:    'app-login',\n  templateUrl: './login.component.html',\n  styleUrls:   ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplates can also be provided as inline strings using the `template` option:\n\n```typescript\n@Component({\n  selector: 'app-login',\n  template: '<form (ngSubmit)=\"onSubmit()\">' + \n            '<input type=\"text\"     placeholder=\"Username\" [(ngModel)]=\"username\" />' +\n            '<input type=\"password\" placeholder=\"Password\" [(ngModel)]=\"password\" />' +\n            '<button type=\"submit\">Login</button>' + \n            '</form>',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplate inject vulnerabilities occur in Angular when untrusted input is passed to the `template` option - in \nparticular, when the template string is generated by string concatenation:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>' + (window.location.hash || 'Home') + '</h1>'\n})\nexport class HeaderComponent {}\n```\n\nAvoid dynamically generated templates in this fashion. Instead, load the state into your component, and use Angular's\nbuilt-in interpolation logic to safely escape any untrusted content:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>{{ title }}</h1>'\n})\nexport class HeaderComponent {\n  title = ''  \n    \n  ngOnInit() {\n    this.title = window.location.hash || 'Home';\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Template Injection in C#\n\nDynamic web pages in ASP.NET Core are rendered using Razor templates that allow interpolation of C# code into\nHTML markup. Razor templates are typically defined as `.cshtml` files at compile time, but you can also dynamically\ngenerate Razor templates at runtime. This latter scenario presents some risks, however. Consider the following action:\n\n```csharp\n[HttpGet(\"/users/{username}/{field}\")]\npublic ActionResult Profile(string username, string field)\n{\n    var razor = new RazorEngine();\n    \n    // Dynamically constructing a template through string interpolation is very dangerous!\n    var template = razor.Compile<IdentityUserModel>(@\"\n        <h1>@username</h1>\n        <h2>@\" + field + \"</h2>\" \n    );\n\n    // Load the user details.\n    var user = LoadUser(username);\n\n    // Render the template.\n    var result = template.Run(user);\n\n    // Return the generated HTML.\n    return Content(result, \"text/html\");\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), an \nattacker will be able to inject extra tags and dynamic content into the template.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your Razor templates are statically defined, rather than generated \nby string concatenation at runtime. This is the default behavior in ASP.NET, so it's very simple to implement:\n\n```csharp\npublic class UserController : Controller\n{\n    [HttpGet(\"/users/{username}/{field}\")]\n    public IActionResult Profile(string username, string field)\n    {\n        // Load the user details.\n        var user = LoadUser(username);\n\n        // Set the state to pass to the template, in the case using the dynamic \"ViewBag\" model.\n        ViewBag.UserName     = username\n        ViewBag.ProfileField = user.GetField(field)\n\n        // Render the template at /Views/User/Profile.cshtml\n        return View();\n    }\n}\n```\n\nThe Razor template `/Views/User/Profile.cshtml` will look like an HTML page that renders the model we pass in:\n\n```html\n<html>\n  <body>\n    <h1>@ViewBag.UserName</h1>\n    <h2>@ViewBag.ProfileField</h2>\n  </body>\n</html>\n```\n\nSince the template is defined on disk, and since the names of the HTML tags are *not* dynamically generated, you are\nprotected from template injection.\n\n:::\n\n:::tab[JavaScript]\n\n## Template Injection in JavaScript\n\nThere are a wide variety of template engines in Node.js which allow interpolation of data, as well as language-native\ntemplate literal strings. Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code:\n\n```javascript\n// Load the EJS template engine.\nconst ejs     = require('ejs')\nconst express = require('express')\n\nconst app = express()\n\napp.get('/:username/:field*', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n  const field     = request.params.field\n\n  const template = `\n    <div>\n      <h1> <%= username %> </h1>\n      <p>  <%= ` + field + ` %> </p>\n    </div>`\n\n  response.send(\n    ejs.render(template, user)\n  )\n})\n```\n\nThis function is intended to take a path like `/username/email` and look up the \"email\" field on that particular user. \nHowever, since the second part of the path is concatenated into the template string (notice the `+` characters), a URL\nlike `/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. Performing a \nsimple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure out how to \nrun commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Express application:\n  \n```javascript\n// Load the 'mustache' template engine.\nconst mustache = require('mustache-express')\nconst express  = require('express')\n\nconst app = express()\n\n// Register the .ms extension for mustache template files.\napp.engine('ms', mustache())\n\n// Register the 'mustache' library as our template engine, tell Express to look for\n// templates in the /views directory.\napp.set('view engine', 'ms')\napp.set('views',       '/views')\n\napp.get('/:username/:field', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n\n  // Render the template '/views/user.ms' using the 'mustache' template engine.\n  response.render('user', {\n    username : username,\n    value    : user[request.params.field]\n  })\n})\n\napp.get('/', (request, response) => {\n  response.render('index', {\n    users: Object.values(users)\n  })\n})\n```\n\nYou should prefer a *less* expressive template engine like `mustache.js` over one like `ejs`. The former tokenizes your \ntemplate files and interpolates data, while the latter uses the `eval(...)` function under the hood. Use of `eval(...)` \nfrequently leads to remote code execution vulnerabilities, as illustrated in our first example.\n\n:::\n\n:::tab[Python]\n\n## Template Injection in Python\n\nThere's a wide variety of templating engines in Python. Jinja2 (the default engine for the Flask web-server) is one of\nthe most popular, and allows easy interpolation of data into HTML. Template files can be loaded from disk, or template\nstrings can be constructed dynamically. The latter scenario presents some risks:\n\n```python\nfrom flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  return render_template_string(\"\"\"\n    <div>\n      <h1> {{ username }} </h1>\n      <p>  {{ \"\"\" + field + \"\"\" }} </p>\n    </div>\n  \"\"\", username=username, field=user.get(field, 'No data'))\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  # Since the template is loaded from disk, we can be sure it is statically defined.\n  return render_template('profile.html', \n                         username = username, \n                         field    = user.get(field, 'No data'))\n```\n\n:::\n\n:::tab[React]\n\n## Template Injection in React\n\nMost React developers use JSX to make HTML tags native in JavaScript syntax. JSX makes it easy to dynamically render \npage elements that correspond to data loaded from the server.\n\nProviding all React components are defined in JSX when the code is transpiled to JavaScript during the build process, \nyou are generally safe from template injection attacks. However, React components *can* be generated directly from the \nlow-level APIs at runtime using the `React.createElement(...)` function. If you invoke this method using untrusted \ncontent, you are vulnerable to template injection attacks:\n\n```jsx\nconst tagName     = 'div'\nconst attributes  = { class: 'page-contents' }\nconst textContent = 'Tag contents go here'\n\n/**\n * Dynamically create a React component, in this case:\n * \n *   <div class=\"page-contents\">Tag contents go here</div>\n *   \n * If any of the arguments come from an untrusted source an attacker can inject malicious content.\n */\nReact.createElement(\n  tagName,\n  attributes,\n  textContent\n)\n```\n\nAttackers can also control the attributes and contents of HTML tags if you invoke the `dangerouslySetInnerHTML` \nfunction on a React component:\n\n```jsx\n/**\n * React allows you to write raw HTML from a string, but discourages it - hence the function name\n * \"dangerouslySetInnerHTML(...)\"! If the inputs to this function are taken from an untrusted source\n * you are vulnerable to template injection.\n */\nconst html = { \n  __html: '<div class=\"page-contents\">Tag contents go here</div>' \n}\n<div dangerouslySetInnerHTML={html} />\n```\n\nThe final source of template injection vulnerabilities in React is `href` attributes. If the `href` attribute of a link \nor import statements is dynamically generated from untrusted content, an attacker can inject JavaScript by supplying a \nURL with a `javascript:` prefix:\n\n```jsx\n/**\n * Dynamically setting the `href` of a link can permit cross-site scripting attacks if the  \n * URL is taken from an untrusted source.\n */\nconst link = \"javascript:alert('Oh no')\"\n    \n// An user clicking on this this component will execute the attacker's JavaScript.\nconst button = <a href={link}>Click here</a>\n```\n\n## Mitigation\n\n* Avoid using the `React.createElement(...)` function directly.\n* Don't use the `dangerouslySetInnerHTML` function on React components.\n* Don't dynamically generate `href` attributes from untrusted content.\n\n:::\n\n:::tab[Scala]\n\n## Template Injection in Scala\n\nThe two most popular template engines in Scala are Twirl, which is used by the Play framework, and Scalate, which \nsupports a variety of templates syntaxes. Both are commonly used to generate dynamic HTML by combining static\ntemplate files with dynamic data. The programmatic instructions within these template files can use the full Scala\nsyntax and typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the templates themselves are generated at runtime. Take a look at \nthis vulnerable code that uses the Scalate library to dynamically create and then evaluate a template string:\n\n```scala\ndef details(username : String, field : String) = Action {\n  val template = new StringTemplateSource(\"file.ssp\", \"<html><h1>${username}</h1><h2>${\" + field + \"}</h2></html>\")\n  val output   = new StringWriter()\n  val context  = new DefaultRenderContext(\"\", engine, new PrintWriter(output))\n\n  val user = User.findByUsername(username)\n\n  for ((key, value) <- user) {\n    context.attributes.update(key, value)\n  }\n\n  engine.compile(template).render(context)\n\n  Ok(output.toString).as(\"text/html\")\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by\nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk. In the \nPlay framework, for example, a Twirl template stored at `/app/views/users/profile.scala.html` can be rendered in an\naction with very simply\n\n```scala\n  def profile(username: String, field: String) = Action {\n    User\n      .findByUsername(username)\n      .map { client =>\n        Ok(views.html.users.profile(user, field))\n      }\n      .getOrElse(NotFound)\n  }\n```\n\nThe template `/app/views/users/profile.scala.html` expects a `User` object and a field name:\n\n```html\n@(user: models.User, field: String)\n<html>\n  <h1>@user.username</h1>\n  <h2>@(user.getField(field))</h2>\n</html>\n```\n\nSince the template is defined on disk there is no risk of dynamically executing malicious content passed by an attacker. \nThis will protect your from template injection attacks.\n\n:::\n\n:::tab[Go]\n\n## Template Injection in Go\n\nDynamic HTML is generally generated in Go using the `html/template` package. Template files can be loaded from disk, or \ntemplate strings can be constructed dynamically. The latter scenario presents some risks, as illustrated by the \nfollowing code:\n\n```go\nimport (\n  \"github.com/gorilla/mux\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n)\n\n// Start up a new web server.\nfunc main() {\n  routes := mux.NewRouter()\n  \n  // Add a route to the profile handler.\n  routes.HandleFunc(\"/user/{username}/{field}\", ProfileDataHandler)\n\n  log.Fatal(http.ListenAndServe(\":8000\", routes))\n}\n\n// Render a user's profile.\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  \n  // Load the user referenced in the URL path.\n  user := loadUser(vars[\"username\"])\n\n  // Dynamically generating the template using string concatenation is very dangerous!\n  templateString := `<div>\n                       <h1> {{ .Username }}</h1>\n                       <p>  {{ .` + strings.Title(vars[\"field\"]) + ` }} </p>\n                     </div>`\n\n  // Render the template.\n  template, err := template.New(\"profile\").Parse(templateString)\n\n  if err != nil {\n    http.Error(response, \"Error parsing template\", http.StatusInternalServerError)\n    return\n  }\n\n  // Return the generated HTML.\n  template.Execute(response, user)\n}\n```\n\nThis routing logic is intended to take a path like `/users/username/email` and look up the \"Email\" field on that \nparticular user. However, since the third part of the path is concatenated into the template string - notice the `+` \ncharacters - the `field` parameter will may also get evaluated as a method call on the `User` object. Depending on \nwhich methods are defined on the the `User` object, this potentially gives an attacker a backdoor method of executing\ncode on your web-server.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```go\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  user := loadUser(vars[\"username\"])\n\n  // Load the template from disk.\n  template, err := template.ParseFiles(\"templates/profile.html\")\n\n  // Prepare the user data we wish to render.\n  data := UserData{\n    Username:     user.Username,\n    ProfileField: user.GetField(vars[\"field\"])\n  }\n  \n  template.Execute(response, data)\n}\n```\n\nThe template file `templates/profile.html` will look like this:\n\n```html\n<div>\n  <h1> {{ .Username     }} </h1>\n  <p>  {{ .ProfileField }} </p>\n</div>\n```\n\nSince the template is defined on disk (rather than generated at runtime), an attacker cannot inject dynamic content -\nmeaning you are safe from template injection attacks.\n\n:::\n\n:::tab[PHP]\n\n## Template Injection in PHP\n\nOne of the most commonly used template engines in PHP is Twig. PHP itself has built-in templating capabilities, but more advanced engines like Twig provide more structure and separation of logic from presentation. \n\nIn PHP, a common area of vulnerability is when user input is interpolated directly into the template string. This can lead to template injections if the user input is treated as part of the template logic rather than simple data.\n\nFor example, consider the following vulnerable code snippet:\n\n```php\n<?php\n$username = $_GET['username'];\n$field = $_GET['field'];\n\n$template = \"<div><h1>{{ username }}</h1><p>{{ $field }}</p></div>\";\n\n// Imagine using Twig or another templating engine here\necho $twig->renderString($template, ['username' => $username]);\n?>\n```\n\nIn this code, `$field` is interpolated directly into the template string. A malicious user could craft an input for `field` that would be treated as template logic, leading to unintended code execution.\n\n## Mitigation\n\nTo mitigate template injection attacks in PHP:\n\n1. **Avoid Interpolating User Input Directly**: As a rule, never interpolate user input directly into template strings. Always pass user data as separate context or variables to the template, allowing the engine to handle the data safely.\n\n   ```php\n   $template = \"<div><h1>{{ username }}</h1><p>{{ field }}</p></div>\";\n   echo $twig->renderString($template, ['username' => $username, 'field' => $field]);\n   ```\n\n2. **Escape User Input**: Always escape user input when it's displayed in the template. This will prevent any malicious input from being treated as template code. Many modern templating engines, including Twig, have automatic escaping by default.\n\n3. **Use Built-in Functions**: Instead of creating templates dynamically, utilize built-in functions like `render()` to fetch pre-defined templates and pass data to them. \n\n   ```php\n   echo $twig->render('profile.twig', ['username' => $username, 'field' => $field]);\n   ```\n\n4. **Limit Template Engine Capabilities**: If your template engine allows for it, restrict the functionalities that can be used within templates. For instance, if there's no need for a template to access the filesystem or execute system commands, disable those capabilities.\n\n5. **Update Regularly**: Ensure that your templating engine and all dependencies are regularly updated. This will ensure you have the latest security patches.\n\nBy following these measures, you can significantly reduce the risk of template injection vulnerabilities in your PHP applications.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-79](https://cwe.mitre.org/data/definitions/79.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a7-Cross-Site_Scripting_(XSS)",
              "id": "xss-to-html-template/3adb6c8fd0d2a901ba252577569b08cf",
              "name": "Template Injection: Http Data Used In Html Template Via R In Xss1handler",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 79",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a7-xss",
                  "Template Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Template Injection: HTTP Data Used in HTML Template via r in xss1Handler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/e8d36a6efd68f7d7cc77a0204c063d7d",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Self.deletesession",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in Self.DeleteSession"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/c0bab1ef36ad605d98af9a801f892c04",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Logout",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in Logout"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "GJSON is a Go package that provides a fast and simple way to get values from a json document. GJSON before 1.9.3 allows a ReDoS (regular expression denial of service) attack."
              },
              "help": {
                "markdown": "GJSON is a Go package that provides a fast and simple way to get values from a json document. GJSON before 1.9.3 allows a ReDoS (regular expression denial of service) attack.",
                "text": "GJSON is a Go package that provides a fast and simple way to get values from a json document. GJSON before 1.9.3 allows a ReDoS (regular expression denial of service) attack."
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/400.html",
              "id": "oss_vuln/a49552ffe7ac568249b08ccad3208275",
              "name": "Pkg:golang/Github.com/Tidwall/Gjson@V1.9.2",
              "properties": {
                "precision": "very-high",
                "security-severity": "7.5",
                "tags": [
                  "CVE-2021-42836",
                  "CVSS 7.5",
                  "CWE 1333",
                  "CWE 400",
                  "CWE 697",
                  "Exploitable",
                  "Unreachable",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "pkg:golang/github.com/tidwall/gjson@v1.9.2"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
              "id": "warning-sink-sql/af6d97798ef8325f40b78476219f447a",
              "name": "Sql Injection: Non-Constant Sql Statement In Createuserstable",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Non-Constant SQL Statement in createUsersTable"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning",
                "rank": -1
              },
              "fullDescription": {
                "text": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability."
              },
              "help": {
                "markdown": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\\/[^\\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\\/[^\\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\\/[^\\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\\/[^\\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\\/[^\\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\\/[^\\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\\/[^\\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\\/[^\\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\\/[^\\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\\/[^\\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/601.html",
              "id": "warning-sink-redirect/4b633639581f06013afa8c2b285a05e5",
              "name": "Open Redirect: Non-Constant Url Target Of Http Redirect In Authcheck@1",
              "properties": {
                "precision": "very-high",
                "security-severity": "4",
                "tags": [
                  "CVSS 4",
                  "CWE 601",
                  "OWASP 2021 a01-broken-access-control",
                  "OWASP a01-2021-broken-access-control",
                  "OWASP a1-injection",
                  "Open Redirect",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Open Redirect: Non-Constant URL Target of HTTP Redirect in AuthCheck@1"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection",
              "id": "sql-injection-attacker-controlled/5b20b3534d2c3143e97531b5b585508a",
              "name": "Sql Injection: Attacker-Controlled Data Used In Sql Query Via R In Sqli2handler",
              "properties": {
                "precision": "very-high",
                "security-severity": "9",
                "tags": [
                  "CVSS 9",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Attacker-controlled Data Used in SQL Query via r in sqli2Handler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/dd305b38f3b52689fbfbcc8095b56134",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Detectsqlmap@1",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in DetectSQLMap@1"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/abeebc310d82290692884b66e0bb7f4f",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Loginviewhandler",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in LoginViewHandler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "File are unzipped without validation. This can lead to an arbitrary file write where existing files and files outside the intended directory are overwritten."
              },
              "help": {
                "markdown": "File are unzipped without validation. This can lead to an arbitrary file write where existing files and files outside the intended directory are overwritten.\n\n# Arbitrary File Writes\n\nIf your web-server writes files to disk, the output filename and path should not be generated from untrusted input. A\nweb-server that permits **arbitrary file writes** to be triggered by specially crafted HTTP requests will allow an\nattacker to drop malicious files on your server or overwrite existing resources.\n\n::::tabs\n\n:::tab[Java]\n\n## Arbitrary File Writes in Java\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Java snippet shows a profile photo upload function that takes the filename from a multipart form request:\n\n```java\n@MultipartConfig\npublic class UnsafeUploadServlet extends HttpServlet\n{\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n    {\n        final String path     = \"/var/tmp/photo\";\n\n        /**\n         * Taking the filename from the HTTP request is dangerous - an attacker\n         * can override any file they wish in the directory, and in this case,\n         * they can use the \"../\" syntax in a filename to climb out of the\n         * intended directory.\n         */\n        final Part   filePart = request.getPart(\"file\");\n        final String fileName = getFileName(filePart);\n\n        OutputStream out    = null;\n        InputStream content = null;\n\n        try\n        {\n            out     = new FileOutputStream(path + File.separator + fileName);\n            content = filePart.getInputStream();\n\n            int read;\n            final byte[] bytes = new byte[1024];\n\n            while ((read = content.read(bytes)) != -1) {\n                out.write(bytes, 0, read);\n            }\n        }\n        catch (FileNotFoundException error)\n        {\n            throw new ServletException(\"Unable to create profile photo on disk\", error);\n        }\n        finally\n        {\n            if (out != null) {\n                out.close();\n            }\n            if (content != null) {\n                content.close();\n            }\n        }\n\n        response.sendRedirect(\"/photo\");\n    }\n\n    private String getFileName(final Part part)\n    {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\\\"\", \"\");\n            }\n        }\n\n        return null;\n    }\n}\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the constructor\nof the `FileOutputStream` class. This will allow the attacker to \"climb out\" of the intended output directory. Using \nthis syntax multiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```java\n        final String path     = \"/var/tmp/photo\";\n        final Part   filePart = request.getPart(\"file\");\n        final String fileName = getFileName(filePart);\n\n        /**\n         * Removing anything except alphanumeric characters (and periods) will\n         * stop the file being written in an arbitrary directory - but it will\n         * still allow files in a given directory to be overwritten.\n         */\n        final String safeFileName = fileName.replaceAll(\"[^a-zA-Z0-9\\\\.]\", \"_\");\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```java\n        final String path = \"/var/tmp/photo\";\n\n        /**\n         * The safest method is to not take any part of the filename from the\n         * HTTP request at all - simply name the file for what it is for\n         * (e.g. the user's name) or generate a random name.\n         */\n        String safeFileName = UUID.randomUUID() + \".jpg\";\n```\n\n:::\n\n:::tab[C#]\n\n## Arbitrary File Writes in C#\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following C# snippet shows a profile photo upload function that takes the filename from a multipart form request\nin an ASP.NET Core web application:\n\n```csharp\n[HttpPost]\n[Route(\"profile/image\")]\npublic async Task<IActionResult> UploadProfilePhoto()\n{\n    var request = HttpContext.Request;\n\n    if (!request.HasFormContentType || \n        !MediaTypeHeaderValue.TryParse(request.ContentType, out var mediaTypeHeader) ||\n        string.IsNullOrEmpty(mediaTypeHeader.Boundary.Value))\n    {\n        return new UnsupportedMediaTypeResult();\n    }\n\n    var reader  = new MultipartReader(mediaTypeHeader.Boundary.Value, request.Body);\n    var section = await reader.ReadNextSectionAsync();\n\n    while (section != null)\n    {\n        var hasContentDispositionHeader = ContentDispositionHeaderValue.TryParse(section.ContentDisposition,\n            out var contentDisposition);\n\n        if (hasContentDispositionHeader && contentDisposition.DispositionType.Equals(\"form-data\") &&\n            !string.IsNullOrEmpty(contentDisposition.FileName.Value))\n        {\n            // The construction of the the path is not safe - if it\n            // contains the \"..%2F\" pattern, it will be treated as\n            // ../ and a hacker can climb out of the static directory.\n            var saveToPath = Path.Combine(\"Profiles\", contentDisposition.FileName.Value);\n\n            using (var targetStream = System.IO.File.Create(saveToPath))\n            {\n                await section.Body.CopyToAsync(targetStream);\n            }\n\n            return Ok();\n        }\n\n        section = await reader.ReadNextSectionAsync();\n    }\n\n    return BadRequest(\"No file data in the request.\");\n}\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the \n`Path.Combine(...)` method. This allows the attacker to \"climb out\" of the intended output directory. Using this \nsyntax multiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```csharp\nif (hasContentDispositionHeader && contentDisposition.DispositionType.Equals(\"form-data\") &&\n    !string.IsNullOrEmpty(contentDisposition.FileName.Value))\n{\n    // Replacing non-alphanumeric characters with an underscore\n    // will stop an attacker traversing directories. \n    var safeFileName = Regex.Replace(contentDisposition.FileName.Value, \"[^0-9a-zA-Z\\\\.]+\", \"_\");\n    var saveToPath   = Path.Combine(\"Profiles\", safeFileName);\n\n    using (var targetStream = System.IO.File.Create(saveToPath))\n    {\n        await section.Body.CopyToAsync(targetStream);\n    }\n\n    return Ok();\n}\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```csharp\nif (hasContentDispositionHeader && contentDisposition.DispositionType.Equals(\"form-data\") &&\n    !string.IsNullOrEmpty(contentDisposition.FileName.Value))\n{\n    // Choosing our own filename secures the upload function. \n    var safeFileName = Path.GetRandomFileName() + \"-profile.jpg\";\n    var saveToPath   = Path.Combine(\"Profiles\", safeFileName);\n\n    using (var targetStream = System.IO.File.Create(saveToPath))\n    {\n        await section.Body.CopyToAsync(targetStream);\n    }\n\n    return Ok();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\n## Arbitrary File Writes in JavaScript\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Node.js snippet shows a profile photo upload function that takes the filename from a multipart form request:\n\n```javascript\nconst express    = require('express')\nconst fs         = require('fs')\nconst multiparty = require('multiparty')\nconst path       = require('path')\n\nconst app = express()\n\napp.post('/profile/photo', (request, response) => {\n  const form = new multiparty.Form()\n\n  form.on('part', (part) => {\n    if (!part.filename) return;\n    if (part.name !== 'image') return part.resume();\n\n    /**\n     * Taking the filename from the HTTP request is dangerous - an attacker\n     * can override any file they wish in the directory, and in this case,\n     * they can use the \"../\" syntax in a filename to climb out of the\n     * intended directory.\n     */\n    const outputPath = path.resolve('profile/photo/', part.filename)\n\n    const fileStream = fs.createWriteStream(\n      outputPath,\n      { flags: 'a'}\n    )\n\n    part.on('data', function(buffer){\n      fileStream.write(buffer)\n    })\n\n    fileStream.on('close', () => {\n      response.redirect('/')\n    })\n  })\n\n  form.on('close', () => {\n    response.redirect('/')\n  })\n\n  form.parse(request)\n})\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename:\n\n```javascript\nconst fs      = require('fs')\nconst request = require('request')\n\nconst url                 = 'http://localhost:4000/profile/photo'\nconst fileToUpload        = './resources/cat.jpg'\nconst whereToWriteTheFile = '../../arbitrary.jpg'\n\nfs.readFile(fileToUpload, (err, content) => {\n  const boundary = 'xxxxxxxxxx'\n\n  let data = ''\n\n  data += '--' + boundary + '\\r\\n'\n  data += 'Content-Disposition: form-data; name=\"image\"; filename=\"' + whereToWriteTheFile + '\"\\r\\n'\n  data += 'Content-Type:application/octet-stream\\r\\n\\r\\n'\n\n  const payload = Buffer.concat([\n    Buffer.from(data, \"utf8\"),\n    new Buffer(content, 'binary'),\n    Buffer.from(\"\\r\\n--\" + boundary + \"--\\r\\n\", \"utf8\")\n  ])\n\n  request({\n    method: 'POST',\n    url:     url,\n    headers: { 'Content-Type': 'multipart/form-data; boundary=' + boundary },\n    body:    payload\n  })\n})\n```\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the\n`path.resolve(...)` call in the upload function. This will allow the attacker to \"climb out\" of the intended output \ndirectory. Using this syntax multiple times allows them to write their malicious file *anywhere* on the server's file\nsystem.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply remove\nany character that is not alphanumeric:\n\n```javascript\napp.post('/profile/photo', (request, response) => {\n  const form = new multiparty.Form()\n\n  form.on('part', (part) => {\n    if (!part.filename) return;\n    if (part.name !== 'image') return part.resume();\n\n    /**\n     * Removing anything except alphanumeric characters (and periods) will\n     * stop the file being written in an arbitrary directory - but it will\n     * still allow files in a given directory to be overwritten.\n     */\n    const suppliedFilename = part.filename\n    const match            = suppliedFilename.match(/([a-z0-9]+)\\.([a-z]+)/i)\n    const scrubbedFileName = match[1] + '.' + match[2]\n\n    const outputPath = 'profile/photo/' + scrubbedFileName\n\n    const fileStream = fs.createWriteStream(\n      outputPath,\n      { flags: 'a'}\n    )\n\n    part.on('data', function(buffer){\n      fileStream.write(buffer)\n    })\n\n    fileStream.on('close', () => {\n      response.redirect('/')\n    })\n  })\n\n  form.on('close', () => {\n    response.redirect('/')\n  })\n\n  form.parse(request)\n})\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```javascript\nconst { v4: uuid } = require('uuid')\n\nconst app = express()\n\napp.post('/profile/photo', (request, response) => {\n  const form = new multiparty.Form()\n\n  form.on('part', (part) => {\n    if (!part.filename) return;\n    if (part.name !== 'image') return part.resume();\n\n    /**\n     * The safest method is to not take any part of the filename from the\n     * HTTP request at all - simply name the file for what it is for\n     * (e.g. the user's name) or generate a random name.\n     */\n    const outputPath = `profile/photo/${uuid()}.jpg`\n\n    const fileStream = fs.createWriteStream(\n      outputPath,\n      { flags: 'a'}\n    )\n\n    part.on('data', function(buffer){\n      fileStream.write(buffer)\n    })\n\n    fileStream.on('close', () => {\n      response.redirect('/')\n    })\n  })\n\n  form.on('close', () => {\n    response.redirect('/')\n  })\n\n  form.parse(request)\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Arbitrary File Writes in Python\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Python snippet shows a profile photo upload function that takes the filename from a multipart form request\nin a Flask web application:\n\n```python\n@app.route('/profile/image', methods=['POST'])\ndef upload_profile_file():\n  \"\"\"An insecure file upload function that exhibits the following flaws:\n\n    * File paths are not sanitized - meaning a hostile user can use\n      relative paths to write files anywhere in the file system.\n\n    * The file name is taken from the request rather than generated,\n      allow a hacker to overwrite existing content.\n  \"\"\"\n  file = request.files['file']\n\n  if file:\n\n    # The construction of the the path is not safe - if it\n    # contains the \"..%2F\" pattern, it will be treated as\n    # ../ and a hacker can climb out of the static directory.\n    path = posixpath.join(app.resources_folder, 'img/profiles/' + file.filename)\n\n    file.save(path)\n\n    user = session['user']\n\n    profile_image = 'profiles/' + file.filename\n\n    with database() as db:\n      db.execute(\"update users set profile = ? where id = ?\", profile_image, user['id'])\n\n    session['user']['profile'] = profile_image\n\n  return { 'message' : 'ok', 'profile' : profile_image }\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the \n`posixpath.join(...)` function. This allows the attacker to \"climb out\" of the intended output directory. Using this \nsyntax multiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```python\n@app.route('/profile/image', methods=['POST'])\ndef upload_profile_file():\n  \"\"\"An more secure file upload function that cleans the filename on uploaded.\"\"\"\n  file = request.files['file']\n\n  if file:\n\n    # Replacing non-alphanumeric characters with an underscore\n    # will stop an attacker traversing directories. \n    safe_filename = re.sub('[^0-9a-zA-Z\\.]+', '_', file.filename)\n      \n    path = os.path.join(app.resources_folder, 'img'. 'profiles', safe_filename)\n\n    file.save(path)\n\n    user = session['user']\n\n    profile_image = 'profiles/' + file.filename\n\n    with database() as db:\n      db.execute(\"update users set profile = ? where id = ?\", profile_image, user['id'])\n\n    session['user']['profile'] = profile_image\n\n  return { 'message' : 'ok', 'profile' : profile_image }\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```python\n@app.route('/profile/image', methods=['POST'])\ndef upload_profile_file():\n  \"\"\"A secure file upload function generates a file name for the uploaded image.\"\"\"\n  file = request.files['file']\n\n  if file:\n    user = session['user']\n    \n    # We assume the username only contains path-safe characters.\n    profile_image = 'profiles/' + user.username + '-profile.jpg'\n    path          = os.path.join(app.resources_folder, 'img', profile_image)\n      \n    file.save(path)\n    \n    with database() as db:\n      db.execute(\"update users set profile = ? where id = ?\", profile_image, user['id'])\n\n    session['user']['profile'] = profile_image\n\n  return { 'message' : 'ok', 'profile' : profile_image }\n```\n\n:::\n\n:::tab[Scala]\n\n## Arbitrary File Writes in Scala\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Scala snippet shows a profile photo upload function that takes the filename from a multipart form request\nin a Play web application:\n\n```scala\n/**\n * Accept the upload of a file from multipart POST request.\n */\ndef upload = Action(parse.multipartFormData(extractFileFromRequest)) { implicit request =>\n  val message = request.body.file(\"name\").map {\n    case FilePart(key, filename, contentType, file, fileSize, dispositionType) =>\n      s\"File $filename uploaded\"\n  }\n\n  Ok(message.getOrElse(\"No file found\"))\n}\n\ntype FileExtractor[A] = FileInfo => Accumulator[ByteString, FilePart[A]]\n\n/**\n * Taking the filename from the HTTP request is dangerous - an attacker\n * can override any file they wish in the directory, and in this case,\n * they can use the \"../\" syntax in a filename to climb out of the\n * intended directory.\n */\nprivate def extractFileFromRequest: FileExtractor[File] = {\n  case FileInfo(partName, filename, contentType, _) =>\n    val path: Path = Path.of(\"/var/tmp/photo\", filename)\n    val fileSink: Sink[ByteString, Future[IOResult]] = FileIO.toPath(path)\n    val accumulator: Accumulator[ByteString, IOResult] = Accumulator(fileSink)\n\n    accumulator.map {\n      case IOResult(count, status) =>\n        logger.info(s\"File with size $count bytes written to $path\")\n        FilePart(partName, filename, contentType, path.toFile)\n    }\n}\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the \n`Path.of(...)`method. This allows the attacker to \"climb out\" of the intended output directory. Using this syntax \nmultiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```scala\nval safeFileName = filename.replaceAll(\"[^a-zA-Z0-9\\\\.]\", \"_\")\nval path: Path = Path.of(\"/var/tmp/photo\", safeFileName)\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```scala\nval safeFileName = s\"${UUID.randomUUID}.jpg\"\nval path: Path = Path.of(\"/var/tmp/photo\", safeFileName)\n```\n\n:::\n\n:::tab[Go]\n\n## Arbitrary File Writes in Go\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Go snippet shows a profile photo upload function that takes the filename from a multipart form request\nusing the Gorilla web toolkit:\n\n```go\nfunc ProfilePhotoUploadHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseMultipartForm(32 << 20)\n\n  uploadedFile, handler, err := request.FormFile(\"image\")\n\n  if err != nil {\n    return\n  }\n\n  defer uploadedFile.Close()\n\n  /**\n   * Taking the filename from the HTTP request is dangerous - an attacker\n   * can override any file they wish in the directory, and in this case,\n   * they can use the \"../\" syntax in a filename to climb out of the\n   * intended directory.\n   */\n  newFile, err := os.OpenFile(\"/profile/photo/\" + handler.Filename, os.O_WRONLY | os.O_CREATE, 0666)\n\n  if err != nil {\n    return\n  }\n\n  io.Copy(newFile, uploadedFile)\n}\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the \n`os.OpenFile(...)` method. This allows the attacker to \"climb out\" of the intended output directory. Using this \nsyntax multiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```go\nfunc ProfilePhotoUploadHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseMultipartForm(32 << 20)\n\n  uploadedFile, handler, err := request.FormFile(\"image\")\n\n  if err != nil {\n    return\n  }\n\n  defer uploadedFile.Close()\n\n  /**\n   * Replacing non-alphanumeric characters with an underscore\n   * will stop an attacker traversing directories.\n   */\n  re           := regexp.MustCompile(`(^[a-zA-Z-9\\.]+)`)\n  safeFilename := re.ReplaceAllString(handler.Filename, \"_\")\n  newFile, err := os.OpenFile(\"profile/photo/\" + safeFilename, os.O_WRONLY | os.O_CREATE, 0666)\n\n  if err != nil {\n    return\n  }\n\n  io.Copy(newFile, uploadedFile)\n}\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```go\nfunc ProfilePhotoUploadHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseMultipartForm(32 << 20)\n\n  uploadedFile, _, err := request.FormFile(\"image\")\n\n  if err != nil {\n    return\n  }\n\n  defer uploadedFile.Close()\n\n  /**\n   * The safest method is to not take any part of the filename from the\n   * HTTP request at all - simply name the file for what it is for\n   * (e.g. the user's name) or generate a random name.\n   */\n  safeFilename := uuid.NewString() + \".jpg\"\n  newFile, err := os.OpenFile(\"./\" + safeFilename, os.O_WRONLY | os.O_CREATE, 0666)\n\n  if err != nil {\n    return\n  }\n\n  io.Copy(newFile, uploadedFile)\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Arbitrary File Writes in PHP\nApplications that manage file uploads in PHP can be vulnerable to attacks if they determine the filename from untrusted sources. Attackers can exploit this vulnerability to place files anywhere in the directory structure or to potentially overwrite crucial files.\n\nThe following PHP snippet showcases a profile photo upload feature where the filename is directly extracted from the `$_FILES` superglobal:\n\n```php\n<?php\n$upload_dir = '/var/tmp/photo/';\n$filename = $_FILES['uploadedFile']['name'];\n\n/**\n * Directly taking the filename from the $_FILES superglobal is risky. \n * An attacker can provide a filename like \"../evil.php\", which can \n * lead to arbitrary file write outside the intended directory.\n */\n$target_file = $upload_dir . $filename;\n\nif(move_uploaded_file($_FILES['uploadedFile']['tmp_name'], $target_file)) {\n    echo \"File uploaded successfully!\";\n} else {\n    echo \"There was an error uploading the file.\";\n}\n?>\n```\nIn the above code, a malicious user could send a file named ../evil.php, and due to the .. directory traversal syntax, the file would be saved outside the intended directory.\n\n## Mitigation\nThe first step in mitigation would be to sanitize the filename by dropping\nany contained directory references:\n\n```php\n$filename = basename($_FILES['uploadedFile']['name']);\n```\nHowever, this could still allow an attacker to overwrite existing files. So the\nmost effective mitigation is to avoid relying on the user-provided filename\naltogether. Instead, use a system-generated filename based on a secure RNG, a\nUUID or an auto-incremented database ID:\n\n```php\n$filename = base64_encode(random_bytes(20)) . '.jpg';\n```\nBy generating a file name on your own, you can ensure the file's location and name are consistent and not influenced by potential malicious inputs.\n\n:::\n\n::::\n\n## Further Considerations\n\n* If you accept archive formats like zip files on your web application, treat the names of files contained within the\n  archive as untrusted. Attackers will attempt to make use of \"unsafe unzipping\" vulnerabilities by generating filenames with\n  relative path syntax.\n\n* If you are storing a lot of file uploads consider using a *Content Delivery Network* (CDN). Storing uploaded content \n  with a third party removes the risk of arbitrary file writes.\n\n* You should store uploaded files on your server in a separate directory from running code, and preferably in a separate disk\n  partition. Make sure your web-server process has only the permissions it needs to function - it shouldn't be able to\n  overwrite any files in the code directory at runtime.\n\n* It's a good idea to validate file types when they are uploaded, and to set a maximum file size.\n\n* Running up-to-date virus scanning software on your servers will help you spot malicious uploads.\n\n\n## Additional information\n\n**[CWE-22](https://cwe.mitre.org/data/definitions/22.html)**\n\n**[CWE-434](https://cwe.mitre.org/data/definitions/434.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**",
                "text": "File are unzipped without validation. This can lead to an arbitrary file write where existing files and files outside the intended directory are overwritten.\n\n# Arbitrary File Writes\n\nIf your web-server writes files to disk, the output filename and path should not be generated from untrusted input. A\nweb-server that permits **arbitrary file writes** to be triggered by specially crafted HTTP requests will allow an\nattacker to drop malicious files on your server or overwrite existing resources.\n\n::::tabs\n\n:::tab[Java]\n\n## Arbitrary File Writes in Java\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Java snippet shows a profile photo upload function that takes the filename from a multipart form request:\n\n```java\n@MultipartConfig\npublic class UnsafeUploadServlet extends HttpServlet\n{\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n    {\n        final String path     = \"/var/tmp/photo\";\n\n        /**\n         * Taking the filename from the HTTP request is dangerous - an attacker\n         * can override any file they wish in the directory, and in this case,\n         * they can use the \"../\" syntax in a filename to climb out of the\n         * intended directory.\n         */\n        final Part   filePart = request.getPart(\"file\");\n        final String fileName = getFileName(filePart);\n\n        OutputStream out    = null;\n        InputStream content = null;\n\n        try\n        {\n            out     = new FileOutputStream(path + File.separator + fileName);\n            content = filePart.getInputStream();\n\n            int read;\n            final byte[] bytes = new byte[1024];\n\n            while ((read = content.read(bytes)) != -1) {\n                out.write(bytes, 0, read);\n            }\n        }\n        catch (FileNotFoundException error)\n        {\n            throw new ServletException(\"Unable to create profile photo on disk\", error);\n        }\n        finally\n        {\n            if (out != null) {\n                out.close();\n            }\n            if (content != null) {\n                content.close();\n            }\n        }\n\n        response.sendRedirect(\"/photo\");\n    }\n\n    private String getFileName(final Part part)\n    {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\\\"\", \"\");\n            }\n        }\n\n        return null;\n    }\n}\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the constructor\nof the `FileOutputStream` class. This will allow the attacker to \"climb out\" of the intended output directory. Using \nthis syntax multiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```java\n        final String path     = \"/var/tmp/photo\";\n        final Part   filePart = request.getPart(\"file\");\n        final String fileName = getFileName(filePart);\n\n        /**\n         * Removing anything except alphanumeric characters (and periods) will\n         * stop the file being written in an arbitrary directory - but it will\n         * still allow files in a given directory to be overwritten.\n         */\n        final String safeFileName = fileName.replaceAll(\"[^a-zA-Z0-9\\\\.]\", \"_\");\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```java\n        final String path = \"/var/tmp/photo\";\n\n        /**\n         * The safest method is to not take any part of the filename from the\n         * HTTP request at all - simply name the file for what it is for\n         * (e.g. the user's name) or generate a random name.\n         */\n        String safeFileName = UUID.randomUUID() + \".jpg\";\n```\n\n:::\n\n:::tab[C#]\n\n## Arbitrary File Writes in C#\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following C# snippet shows a profile photo upload function that takes the filename from a multipart form request\nin an ASP.NET Core web application:\n\n```csharp\n[HttpPost]\n[Route(\"profile/image\")]\npublic async Task<IActionResult> UploadProfilePhoto()\n{\n    var request = HttpContext.Request;\n\n    if (!request.HasFormContentType || \n        !MediaTypeHeaderValue.TryParse(request.ContentType, out var mediaTypeHeader) ||\n        string.IsNullOrEmpty(mediaTypeHeader.Boundary.Value))\n    {\n        return new UnsupportedMediaTypeResult();\n    }\n\n    var reader  = new MultipartReader(mediaTypeHeader.Boundary.Value, request.Body);\n    var section = await reader.ReadNextSectionAsync();\n\n    while (section != null)\n    {\n        var hasContentDispositionHeader = ContentDispositionHeaderValue.TryParse(section.ContentDisposition,\n            out var contentDisposition);\n\n        if (hasContentDispositionHeader && contentDisposition.DispositionType.Equals(\"form-data\") &&\n            !string.IsNullOrEmpty(contentDisposition.FileName.Value))\n        {\n            // The construction of the the path is not safe - if it\n            // contains the \"..%2F\" pattern, it will be treated as\n            // ../ and a hacker can climb out of the static directory.\n            var saveToPath = Path.Combine(\"Profiles\", contentDisposition.FileName.Value);\n\n            using (var targetStream = System.IO.File.Create(saveToPath))\n            {\n                await section.Body.CopyToAsync(targetStream);\n            }\n\n            return Ok();\n        }\n\n        section = await reader.ReadNextSectionAsync();\n    }\n\n    return BadRequest(\"No file data in the request.\");\n}\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the \n`Path.Combine(...)` method. This allows the attacker to \"climb out\" of the intended output directory. Using this \nsyntax multiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```csharp\nif (hasContentDispositionHeader && contentDisposition.DispositionType.Equals(\"form-data\") &&\n    !string.IsNullOrEmpty(contentDisposition.FileName.Value))\n{\n    // Replacing non-alphanumeric characters with an underscore\n    // will stop an attacker traversing directories. \n    var safeFileName = Regex.Replace(contentDisposition.FileName.Value, \"[^0-9a-zA-Z\\\\.]+\", \"_\");\n    var saveToPath   = Path.Combine(\"Profiles\", safeFileName);\n\n    using (var targetStream = System.IO.File.Create(saveToPath))\n    {\n        await section.Body.CopyToAsync(targetStream);\n    }\n\n    return Ok();\n}\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```csharp\nif (hasContentDispositionHeader && contentDisposition.DispositionType.Equals(\"form-data\") &&\n    !string.IsNullOrEmpty(contentDisposition.FileName.Value))\n{\n    // Choosing our own filename secures the upload function. \n    var safeFileName = Path.GetRandomFileName() + \"-profile.jpg\";\n    var saveToPath   = Path.Combine(\"Profiles\", safeFileName);\n\n    using (var targetStream = System.IO.File.Create(saveToPath))\n    {\n        await section.Body.CopyToAsync(targetStream);\n    }\n\n    return Ok();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\n## Arbitrary File Writes in JavaScript\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Node.js snippet shows a profile photo upload function that takes the filename from a multipart form request:\n\n```javascript\nconst express    = require('express')\nconst fs         = require('fs')\nconst multiparty = require('multiparty')\nconst path       = require('path')\n\nconst app = express()\n\napp.post('/profile/photo', (request, response) => {\n  const form = new multiparty.Form()\n\n  form.on('part', (part) => {\n    if (!part.filename) return;\n    if (part.name !== 'image') return part.resume();\n\n    /**\n     * Taking the filename from the HTTP request is dangerous - an attacker\n     * can override any file they wish in the directory, and in this case,\n     * they can use the \"../\" syntax in a filename to climb out of the\n     * intended directory.\n     */\n    const outputPath = path.resolve('profile/photo/', part.filename)\n\n    const fileStream = fs.createWriteStream(\n      outputPath,\n      { flags: 'a'}\n    )\n\n    part.on('data', function(buffer){\n      fileStream.write(buffer)\n    })\n\n    fileStream.on('close', () => {\n      response.redirect('/')\n    })\n  })\n\n  form.on('close', () => {\n    response.redirect('/')\n  })\n\n  form.parse(request)\n})\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename:\n\n```javascript\nconst fs      = require('fs')\nconst request = require('request')\n\nconst url                 = 'http://localhost:4000/profile/photo'\nconst fileToUpload        = './resources/cat.jpg'\nconst whereToWriteTheFile = '../../arbitrary.jpg'\n\nfs.readFile(fileToUpload, (err, content) => {\n  const boundary = 'xxxxxxxxxx'\n\n  let data = ''\n\n  data += '--' + boundary + '\\r\\n'\n  data += 'Content-Disposition: form-data; name=\"image\"; filename=\"' + whereToWriteTheFile + '\"\\r\\n'\n  data += 'Content-Type:application/octet-stream\\r\\n\\r\\n'\n\n  const payload = Buffer.concat([\n    Buffer.from(data, \"utf8\"),\n    new Buffer(content, 'binary'),\n    Buffer.from(\"\\r\\n--\" + boundary + \"--\\r\\n\", \"utf8\")\n  ])\n\n  request({\n    method: 'POST',\n    url:     url,\n    headers: { 'Content-Type': 'multipart/form-data; boundary=' + boundary },\n    body:    payload\n  })\n})\n```\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the\n`path.resolve(...)` call in the upload function. This will allow the attacker to \"climb out\" of the intended output \ndirectory. Using this syntax multiple times allows them to write their malicious file *anywhere* on the server's file\nsystem.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply remove\nany character that is not alphanumeric:\n\n```javascript\napp.post('/profile/photo', (request, response) => {\n  const form = new multiparty.Form()\n\n  form.on('part', (part) => {\n    if (!part.filename) return;\n    if (part.name !== 'image') return part.resume();\n\n    /**\n     * Removing anything except alphanumeric characters (and periods) will\n     * stop the file being written in an arbitrary directory - but it will\n     * still allow files in a given directory to be overwritten.\n     */\n    const suppliedFilename = part.filename\n    const match            = suppliedFilename.match(/([a-z0-9]+)\\.([a-z]+)/i)\n    const scrubbedFileName = match[1] + '.' + match[2]\n\n    const outputPath = 'profile/photo/' + scrubbedFileName\n\n    const fileStream = fs.createWriteStream(\n      outputPath,\n      { flags: 'a'}\n    )\n\n    part.on('data', function(buffer){\n      fileStream.write(buffer)\n    })\n\n    fileStream.on('close', () => {\n      response.redirect('/')\n    })\n  })\n\n  form.on('close', () => {\n    response.redirect('/')\n  })\n\n  form.parse(request)\n})\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```javascript\nconst { v4: uuid } = require('uuid')\n\nconst app = express()\n\napp.post('/profile/photo', (request, response) => {\n  const form = new multiparty.Form()\n\n  form.on('part', (part) => {\n    if (!part.filename) return;\n    if (part.name !== 'image') return part.resume();\n\n    /**\n     * The safest method is to not take any part of the filename from the\n     * HTTP request at all - simply name the file for what it is for\n     * (e.g. the user's name) or generate a random name.\n     */\n    const outputPath = `profile/photo/${uuid()}.jpg`\n\n    const fileStream = fs.createWriteStream(\n      outputPath,\n      { flags: 'a'}\n    )\n\n    part.on('data', function(buffer){\n      fileStream.write(buffer)\n    })\n\n    fileStream.on('close', () => {\n      response.redirect('/')\n    })\n  })\n\n  form.on('close', () => {\n    response.redirect('/')\n  })\n\n  form.parse(request)\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Arbitrary File Writes in Python\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Python snippet shows a profile photo upload function that takes the filename from a multipart form request\nin a Flask web application:\n\n```python\n@app.route('/profile/image', methods=['POST'])\ndef upload_profile_file():\n  \"\"\"An insecure file upload function that exhibits the following flaws:\n\n    * File paths are not sanitized - meaning a hostile user can use\n      relative paths to write files anywhere in the file system.\n\n    * The file name is taken from the request rather than generated,\n      allow a hacker to overwrite existing content.\n  \"\"\"\n  file = request.files['file']\n\n  if file:\n\n    # The construction of the the path is not safe - if it\n    # contains the \"..%2F\" pattern, it will be treated as\n    # ../ and a hacker can climb out of the static directory.\n    path = posixpath.join(app.resources_folder, 'img/profiles/' + file.filename)\n\n    file.save(path)\n\n    user = session['user']\n\n    profile_image = 'profiles/' + file.filename\n\n    with database() as db:\n      db.execute(\"update users set profile = ? where id = ?\", profile_image, user['id'])\n\n    session['user']['profile'] = profile_image\n\n  return { 'message' : 'ok', 'profile' : profile_image }\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the \n`posixpath.join(...)` function. This allows the attacker to \"climb out\" of the intended output directory. Using this \nsyntax multiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```python\n@app.route('/profile/image', methods=['POST'])\ndef upload_profile_file():\n  \"\"\"An more secure file upload function that cleans the filename on uploaded.\"\"\"\n  file = request.files['file']\n\n  if file:\n\n    # Replacing non-alphanumeric characters with an underscore\n    # will stop an attacker traversing directories. \n    safe_filename = re.sub('[^0-9a-zA-Z\\.]+', '_', file.filename)\n      \n    path = os.path.join(app.resources_folder, 'img'. 'profiles', safe_filename)\n\n    file.save(path)\n\n    user = session['user']\n\n    profile_image = 'profiles/' + file.filename\n\n    with database() as db:\n      db.execute(\"update users set profile = ? where id = ?\", profile_image, user['id'])\n\n    session['user']['profile'] = profile_image\n\n  return { 'message' : 'ok', 'profile' : profile_image }\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```python\n@app.route('/profile/image', methods=['POST'])\ndef upload_profile_file():\n  \"\"\"A secure file upload function generates a file name for the uploaded image.\"\"\"\n  file = request.files['file']\n\n  if file:\n    user = session['user']\n    \n    # We assume the username only contains path-safe characters.\n    profile_image = 'profiles/' + user.username + '-profile.jpg'\n    path          = os.path.join(app.resources_folder, 'img', profile_image)\n      \n    file.save(path)\n    \n    with database() as db:\n      db.execute(\"update users set profile = ? where id = ?\", profile_image, user['id'])\n\n    session['user']['profile'] = profile_image\n\n  return { 'message' : 'ok', 'profile' : profile_image }\n```\n\n:::\n\n:::tab[Scala]\n\n## Arbitrary File Writes in Scala\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Scala snippet shows a profile photo upload function that takes the filename from a multipart form request\nin a Play web application:\n\n```scala\n/**\n * Accept the upload of a file from multipart POST request.\n */\ndef upload = Action(parse.multipartFormData(extractFileFromRequest)) { implicit request =>\n  val message = request.body.file(\"name\").map {\n    case FilePart(key, filename, contentType, file, fileSize, dispositionType) =>\n      s\"File $filename uploaded\"\n  }\n\n  Ok(message.getOrElse(\"No file found\"))\n}\n\ntype FileExtractor[A] = FileInfo => Accumulator[ByteString, FilePart[A]]\n\n/**\n * Taking the filename from the HTTP request is dangerous - an attacker\n * can override any file they wish in the directory, and in this case,\n * they can use the \"../\" syntax in a filename to climb out of the\n * intended directory.\n */\nprivate def extractFileFromRequest: FileExtractor[File] = {\n  case FileInfo(partName, filename, contentType, _) =>\n    val path: Path = Path.of(\"/var/tmp/photo\", filename)\n    val fileSink: Sink[ByteString, Future[IOResult]] = FileIO.toPath(path)\n    val accumulator: Accumulator[ByteString, IOResult] = Accumulator(fileSink)\n\n    accumulator.map {\n      case IOResult(count, status) =>\n        logger.info(s\"File with size $count bytes written to $path\")\n        FilePart(partName, filename, contentType, path.toFile)\n    }\n}\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the \n`Path.of(...)`method. This allows the attacker to \"climb out\" of the intended output directory. Using this syntax \nmultiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```scala\nval safeFileName = filename.replaceAll(\"[^a-zA-Z0-9\\\\.]\", \"_\")\nval path: Path = Path.of(\"/var/tmp/photo\", safeFileName)\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```scala\nval safeFileName = s\"${UUID.randomUUID}.jpg\"\nval path: Path = Path.of(\"/var/tmp/photo\", safeFileName)\n```\n\n:::\n\n:::tab[Go]\n\n## Arbitrary File Writes in Go\n\nFile upload functions on websites are a favorite target for hackers because they can write a potentially malicious file\nto your server. If the filename is taken from the HTTP request, the attacker can control where in the directory the\nfile is written to. If the attacker can include *relative path* syntax in the filename, they can write to *any* location \non the server. \n\nThe following Go snippet shows a profile photo upload function that takes the filename from a multipart form request\nusing the Gorilla web toolkit:\n\n```go\nfunc ProfilePhotoUploadHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseMultipartForm(32 << 20)\n\n  uploadedFile, handler, err := request.FormFile(\"image\")\n\n  if err != nil {\n    return\n  }\n\n  defer uploadedFile.Close()\n\n  /**\n   * Taking the filename from the HTTP request is dangerous - an attacker\n   * can override any file they wish in the directory, and in this case,\n   * they can use the \"../\" syntax in a filename to climb out of the\n   * intended directory.\n   */\n  newFile, err := os.OpenFile(\"/profile/photo/\" + handler.Filename, os.O_WRONLY | os.O_CREATE, 0666)\n\n  if err != nil {\n    return\n  }\n\n  io.Copy(newFile, uploadedFile)\n}\n```\n\nThis function takes the filename from the HTTP request. In a normal interaction with the browser, this is the name of the\nfile the user has selected to upload. However, with a few lines of code, an attacker can craft a script to upload a\nfile with an arbitrary filename like `../command.sh`\n\nThe `../` syntax in the \"filename\" will be interpreted as a request to move to the parent directory by the \n`os.OpenFile(...)` method. This allows the attacker to \"climb out\" of the intended output directory. Using this \nsyntax multiple times allows them to write their malicious file *anywhere* on the server's file system.\n\n## Mitigation\n\nOne easy way to mitigate this attack is to remove suspicious characters from the filename. Here we simply replace\nany character that is not alphanumeric (or a period) with an underscore character:\n\n```go\nfunc ProfilePhotoUploadHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseMultipartForm(32 << 20)\n\n  uploadedFile, handler, err := request.FormFile(\"image\")\n\n  if err != nil {\n    return\n  }\n\n  defer uploadedFile.Close()\n\n  /**\n   * Replacing non-alphanumeric characters with an underscore\n   * will stop an attacker traversing directories.\n   */\n  re           := regexp.MustCompile(`(^[a-zA-Z-9\\.]+)`)\n  safeFilename := re.ReplaceAllString(handler.Filename, \"_\")\n  newFile, err := os.OpenFile(\"profile/photo/\" + safeFilename, os.O_WRONLY | os.O_CREATE, 0666)\n\n  if err != nil {\n    return\n  }\n\n  io.Copy(newFile, uploadedFile)\n}\n```\n\nThis still allows the attacker to write the file with any extension they please, and potentially overwrite any files\nthat exist with that name. The best approach is to generate a name for the file on the server - either a completely\nrandom name, or something meaningful, like `<username>-profile.jpg`. You will have to record this filename to a database\n(e.g. against the record for that user) to make use of it later:\n\n```go\nfunc ProfilePhotoUploadHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseMultipartForm(32 << 20)\n\n  uploadedFile, _, err := request.FormFile(\"image\")\n\n  if err != nil {\n    return\n  }\n\n  defer uploadedFile.Close()\n\n  /**\n   * The safest method is to not take any part of the filename from the\n   * HTTP request at all - simply name the file for what it is for\n   * (e.g. the user's name) or generate a random name.\n   */\n  safeFilename := uuid.NewString() + \".jpg\"\n  newFile, err := os.OpenFile(\"./\" + safeFilename, os.O_WRONLY | os.O_CREATE, 0666)\n\n  if err != nil {\n    return\n  }\n\n  io.Copy(newFile, uploadedFile)\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Arbitrary File Writes in PHP\nApplications that manage file uploads in PHP can be vulnerable to attacks if they determine the filename from untrusted sources. Attackers can exploit this vulnerability to place files anywhere in the directory structure or to potentially overwrite crucial files.\n\nThe following PHP snippet showcases a profile photo upload feature where the filename is directly extracted from the `$_FILES` superglobal:\n\n```php\n<?php\n$upload_dir = '/var/tmp/photo/';\n$filename = $_FILES['uploadedFile']['name'];\n\n/**\n * Directly taking the filename from the $_FILES superglobal is risky. \n * An attacker can provide a filename like \"../evil.php\", which can \n * lead to arbitrary file write outside the intended directory.\n */\n$target_file = $upload_dir . $filename;\n\nif(move_uploaded_file($_FILES['uploadedFile']['tmp_name'], $target_file)) {\n    echo \"File uploaded successfully!\";\n} else {\n    echo \"There was an error uploading the file.\";\n}\n?>\n```\nIn the above code, a malicious user could send a file named ../evil.php, and due to the .. directory traversal syntax, the file would be saved outside the intended directory.\n\n## Mitigation\nThe first step in mitigation would be to sanitize the filename by dropping\nany contained directory references:\n\n```php\n$filename = basename($_FILES['uploadedFile']['name']);\n```\nHowever, this could still allow an attacker to overwrite existing files. So the\nmost effective mitigation is to avoid relying on the user-provided filename\naltogether. Instead, use a system-generated filename based on a secure RNG, a\nUUID or an auto-incremented database ID:\n\n```php\n$filename = base64_encode(random_bytes(20)) . '.jpg';\n```\nBy generating a file name on your own, you can ensure the file's location and name are consistent and not influenced by potential malicious inputs.\n\n:::\n\n::::\n\n## Further Considerations\n\n* If you accept archive formats like zip files on your web application, treat the names of files contained within the\n  archive as untrusted. Attackers will attempt to make use of \"unsafe unzipping\" vulnerabilities by generating filenames with\n  relative path syntax.\n\n* If you are storing a lot of file uploads consider using a *Content Delivery Network* (CDN). Storing uploaded content \n  with a third party removes the risk of arbitrary file writes.\n\n* You should store uploaded files on your server in a separate directory from running code, and preferably in a separate disk\n  partition. Make sure your web-server process has only the permissions it needs to function - it shouldn't be able to\n  overwrite any files in the code directory at runtime.\n\n* It's a good idea to validate file types when they are uploaded, and to set a maximum file size.\n\n* Running up-to-date virus scanning software on your servers will help you spot malicious uploads.\n\n\n## Additional information\n\n**[CWE-22](https://cwe.mitre.org/data/definitions/22.html)**\n\n**[CWE-434](https://cwe.mitre.org/data/definitions/434.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control",
              "id": "directory-traversal-http-unzip/988bbb0a2d15ca3f55a138573c5851bc",
              "name": "Directory Traversal: Unsafe Unzipping Via R In Pathtraversalhandler",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 22",
                  "CWE 434",
                  "Directory Traversal",
                  "OWASP 2021 a01-broken-access-control",
                  "OWASP a01-2021-broken-access-control",
                  "OWASP a5-broken-access-control",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Directory Traversal: Unsafe Unzipping via r in pathTraversalHandler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
              "id": "warning-sink-sql/8f29933f2aeb9237860702e08752127c",
              "name": "Sql Injection: Non-Constant Sql Statement In Connect",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Non-Constant SQL Statement in Connect"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
              "id": "warning-sink-sql/7f4524808dfc6947bffade7f0066f457",
              "name": "Sql Injection: Non-Constant Sql Statement In Createprofiletable",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Non-Constant SQL Statement in createProfileTable"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
              "id": "warning-sink-sql/f61dd1bc9f8870ba6e57674b1bd4e50e",
              "name": "Sql Injection: Non-Constant Sql Statement In Createprofiletable",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Non-Constant SQL Statement in createProfileTable"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1."
              },
              "help": {
                "markdown": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**",
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure",
              "id": "weak-hash/c00d9848ecbe39d0fccfc5420df95ce2",
              "name": "Weak Hash: Usage Of Weak Cryptographic Hash Function In Md5sum",
              "properties": {
                "precision": "very-high",
                "security-severity": "3",
                "tags": [
                  "CVSS 3",
                  "CWE 327",
                  "CWE 328",
                  "OWASP 2021 a02-cryptographic-failures",
                  "OWASP a02-2021-cryptographic-failures",
                  "OWASP a3-sensitive-data-exposure",
                  "Weak Hash",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Weak Hash: Usage of Weak Cryptographic Hash Function in Md5Sum"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/6d013abff1bf54c5332ed5f58e488d43",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Setupviewhandler",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in setupViewHandler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/26bf9a433d2ee80286779b18ca6c2fdb",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Setupactionhandler",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in setupActionHandler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
              "id": "warning-sink-sql/b6e4ef5d675f2a2d6196428209d80e80",
              "name": "Sql Injection: Non-Constant Sql Statement In Createuserstable",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Non-Constant SQL Statement in createUsersTable"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/e5bfbebfdc3068e21ade9da6f0b203ad",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Loggingmiddleware@1",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in LoggingMiddleware@1"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/0a1a4cd9aa85f7b751ef9d8751ba9ff7",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Setlevelaction",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in setLevelAction"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The software listens for plain-text HTTP requests without authenticity or integrity protection."
              },
              "help": {
                "markdown": "The software listens for plain-text HTTP requests without authenticity or integrity protection.\n\nAn attacker may be able to access the server under the identity of legitimate users.\n\n\n## Countermeasures\n\n - Enable TLS protection for the web server.\n - If TLS protection is provided by another component in front of the application, ensure that firewall rules are in place that prevent access to the unprotected web server.\n\n## Additional information\n\n**[CWE-419](https://cwe.mitre.org/data/definitions/419.html)**",
                "text": "The software listens for plain-text HTTP requests without authenticity or integrity protection.\n\nAn attacker may be able to access the server under the identity of legitimate users.\n\n\n## Countermeasures\n\n - Enable TLS protection for the web server.\n - If TLS protection is provided by another component in front of the application, ensure that firewall rules are in place that prevent access to the unprotected web server.\n\n## Additional information\n\n**[CWE-419](https://cwe.mitre.org/data/definitions/419.html)**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a6-Security_Misconfiguration",
              "id": "http-no-ssl/68ca27584f44d372afb90a4d5cfa6976",
              "name": "Security Misconfiguration: Web Server Without Tls Protection In Main",
              "properties": {
                "precision": "very-high",
                "security-severity": "1",
                "tags": [
                  "CVSS 1",
                  "CWE 419",
                  "OWASP 2021 a04-insecure-design",
                  "OWASP a04-2021-insecure-design",
                  "OWASP a6-security-misconfiguration",
                  "Security Misconfiguration",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Security Misconfiguration: Web Server Without TLS Protection in main"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
              "id": "warning-sink-sql/ffc7f2703609e00dbee5a6a6c63ad619",
              "name": "Sql Injection: Non-Constant Sql Statement In Createuserstable",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Non-Constant SQL Statement in createUsersTable"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability."
              },
              "help": {
                "markdown": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability.\n\n# Template Injection\n\nIn web design, a *template* is an HTML-like file interspersed with programmatic instructions to be interpreted by the\nweb-server or JavaScript code in the browser at runtime. A template is a *static* file used to generate HTML by \ninterpolating *dynamic* content retrieved from a database or pulled from HTTP. \n\nA **template injection** vulnerability occurs when the dynamic content is treated by the template engine as code to be \nexecuted rather data to be interpolated. This will allow an attacker to execute malicious code on your server or in a \nvictim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Template Injection in Java\n\nThere are a wide variety of template engines in Java which allow interpolation of data, the most commonly used of which\nis Java Server Pages (JSPs). Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code that uses the Pebble template engine:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine engine = new PebbleEngine.Builder().build();\n        \n        PebbleTemplate compiledTemplate = engine.getLiteralTemplate(\n            \"<div><h1>{{username}}</h1><p>{{\" + field + \"}}</p></div>\"\n        );\n\n        Map<String, Object> user = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        compiledTemplate.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Java application:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine        engine   = new PebbleEngine.Builder().build();\n        PebbleTemplate      template = engine.getTemplate(\"profile.tmp\");\n        Map<String, Object> user     = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        template.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\n:::\n\n:::tab[Angular]\n\n## Template Injection in Angular\n\nAngular apps consist of a hierarchical set of components that encapsulate application logic and state information. Each \ncomponent is rendered in the browser using a template that describes the HTML to output for the given state of the\ncomponent. Angular templates will safely interpolate state using the `{{` and `}}` delimiters, and allow components\nto listen for user interactions using event handlers.\n\nA template is attached to a component using the `@Component` decorator. Templates can be specified with the\n`templateUrl` option, which supplies the relative or absolute path of the corresponding template file:\n\n```typescript\n@Component({\n  selector:    'app-login',\n  templateUrl: './login.component.html',\n  styleUrls:   ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplates can also be provided as inline strings using the `template` option:\n\n```typescript\n@Component({\n  selector: 'app-login',\n  template: '<form (ngSubmit)=\"onSubmit()\">' + \n            '<input type=\"text\"     placeholder=\"Username\" [(ngModel)]=\"username\" />' +\n            '<input type=\"password\" placeholder=\"Password\" [(ngModel)]=\"password\" />' +\n            '<button type=\"submit\">Login</button>' + \n            '</form>',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplate inject vulnerabilities occur in Angular when untrusted input is passed to the `template` option - in \nparticular, when the template string is generated by string concatenation:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>' + (window.location.hash || 'Home') + '</h1>'\n})\nexport class HeaderComponent {}\n```\n\nAvoid dynamically generated templates in this fashion. Instead, load the state into your component, and use Angular's\nbuilt-in interpolation logic to safely escape any untrusted content:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>{{ title }}</h1>'\n})\nexport class HeaderComponent {\n  title = ''  \n    \n  ngOnInit() {\n    this.title = window.location.hash || 'Home';\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Template Injection in C#\n\nDynamic web pages in ASP.NET Core are rendered using Razor templates that allow interpolation of C# code into\nHTML markup. Razor templates are typically defined as `.cshtml` files at compile time, but you can also dynamically\ngenerate Razor templates at runtime. This latter scenario presents some risks, however. Consider the following action:\n\n```csharp\n[HttpGet(\"/users/{username}/{field}\")]\npublic ActionResult Profile(string username, string field)\n{\n    var razor = new RazorEngine();\n    \n    // Dynamically constructing a template through string interpolation is very dangerous!\n    var template = razor.Compile<IdentityUserModel>(@\"\n        <h1>@username</h1>\n        <h2>@\" + field + \"</h2>\" \n    );\n\n    // Load the user details.\n    var user = LoadUser(username);\n\n    // Render the template.\n    var result = template.Run(user);\n\n    // Return the generated HTML.\n    return Content(result, \"text/html\");\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), an \nattacker will be able to inject extra tags and dynamic content into the template.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your Razor templates are statically defined, rather than generated \nby string concatenation at runtime. This is the default behavior in ASP.NET, so it's very simple to implement:\n\n```csharp\npublic class UserController : Controller\n{\n    [HttpGet(\"/users/{username}/{field}\")]\n    public IActionResult Profile(string username, string field)\n    {\n        // Load the user details.\n        var user = LoadUser(username);\n\n        // Set the state to pass to the template, in the case using the dynamic \"ViewBag\" model.\n        ViewBag.UserName     = username\n        ViewBag.ProfileField = user.GetField(field)\n\n        // Render the template at /Views/User/Profile.cshtml\n        return View();\n    }\n}\n```\n\nThe Razor template `/Views/User/Profile.cshtml` will look like an HTML page that renders the model we pass in:\n\n```html\n<html>\n  <body>\n    <h1>@ViewBag.UserName</h1>\n    <h2>@ViewBag.ProfileField</h2>\n  </body>\n</html>\n```\n\nSince the template is defined on disk, and since the names of the HTML tags are *not* dynamically generated, you are\nprotected from template injection.\n\n:::\n\n:::tab[JavaScript]\n\n## Template Injection in JavaScript\n\nThere are a wide variety of template engines in Node.js which allow interpolation of data, as well as language-native\ntemplate literal strings. Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code:\n\n```javascript\n// Load the EJS template engine.\nconst ejs     = require('ejs')\nconst express = require('express')\n\nconst app = express()\n\napp.get('/:username/:field*', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n  const field     = request.params.field\n\n  const template = `\n    <div>\n      <h1> <%= username %> </h1>\n      <p>  <%= ` + field + ` %> </p>\n    </div>`\n\n  response.send(\n    ejs.render(template, user)\n  )\n})\n```\n\nThis function is intended to take a path like `/username/email` and look up the \"email\" field on that particular user. \nHowever, since the second part of the path is concatenated into the template string (notice the `+` characters), a URL\nlike `/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. Performing a \nsimple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure out how to \nrun commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Express application:\n  \n```javascript\n// Load the 'mustache' template engine.\nconst mustache = require('mustache-express')\nconst express  = require('express')\n\nconst app = express()\n\n// Register the .ms extension for mustache template files.\napp.engine('ms', mustache())\n\n// Register the 'mustache' library as our template engine, tell Express to look for\n// templates in the /views directory.\napp.set('view engine', 'ms')\napp.set('views',       '/views')\n\napp.get('/:username/:field', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n\n  // Render the template '/views/user.ms' using the 'mustache' template engine.\n  response.render('user', {\n    username : username,\n    value    : user[request.params.field]\n  })\n})\n\napp.get('/', (request, response) => {\n  response.render('index', {\n    users: Object.values(users)\n  })\n})\n```\n\nYou should prefer a *less* expressive template engine like `mustache.js` over one like `ejs`. The former tokenizes your \ntemplate files and interpolates data, while the latter uses the `eval(...)` function under the hood. Use of `eval(...)` \nfrequently leads to remote code execution vulnerabilities, as illustrated in our first example.\n\n:::\n\n:::tab[Python]\n\n## Template Injection in Python\n\nThere's a wide variety of templating engines in Python. Jinja2 (the default engine for the Flask web-server) is one of\nthe most popular, and allows easy interpolation of data into HTML. Template files can be loaded from disk, or template\nstrings can be constructed dynamically. The latter scenario presents some risks:\n\n```python\nfrom flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  return render_template_string(\"\"\"\n    <div>\n      <h1> {{ username }} </h1>\n      <p>  {{ \"\"\" + field + \"\"\" }} </p>\n    </div>\n  \"\"\", username=username, field=user.get(field, 'No data'))\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  # Since the template is loaded from disk, we can be sure it is statically defined.\n  return render_template('profile.html', \n                         username = username, \n                         field    = user.get(field, 'No data'))\n```\n\n:::\n\n:::tab[React]\n\n## Template Injection in React\n\nMost React developers use JSX to make HTML tags native in JavaScript syntax. JSX makes it easy to dynamically render \npage elements that correspond to data loaded from the server.\n\nProviding all React components are defined in JSX when the code is transpiled to JavaScript during the build process, \nyou are generally safe from template injection attacks. However, React components *can* be generated directly from the \nlow-level APIs at runtime using the `React.createElement(...)` function. If you invoke this method using untrusted \ncontent, you are vulnerable to template injection attacks:\n\n```jsx\nconst tagName     = 'div'\nconst attributes  = { class: 'page-contents' }\nconst textContent = 'Tag contents go here'\n\n/**\n * Dynamically create a React component, in this case:\n * \n *   <div class=\"page-contents\">Tag contents go here</div>\n *   \n * If any of the arguments come from an untrusted source an attacker can inject malicious content.\n */\nReact.createElement(\n  tagName,\n  attributes,\n  textContent\n)\n```\n\nAttackers can also control the attributes and contents of HTML tags if you invoke the `dangerouslySetInnerHTML` \nfunction on a React component:\n\n```jsx\n/**\n * React allows you to write raw HTML from a string, but discourages it - hence the function name\n * \"dangerouslySetInnerHTML(...)\"! If the inputs to this function are taken from an untrusted source\n * you are vulnerable to template injection.\n */\nconst html = { \n  __html: '<div class=\"page-contents\">Tag contents go here</div>' \n}\n<div dangerouslySetInnerHTML={html} />\n```\n\nThe final source of template injection vulnerabilities in React is `href` attributes. If the `href` attribute of a link \nor import statements is dynamically generated from untrusted content, an attacker can inject JavaScript by supplying a \nURL with a `javascript:` prefix:\n\n```jsx\n/**\n * Dynamically setting the `href` of a link can permit cross-site scripting attacks if the  \n * URL is taken from an untrusted source.\n */\nconst link = \"javascript:alert('Oh no')\"\n    \n// An user clicking on this this component will execute the attacker's JavaScript.\nconst button = <a href={link}>Click here</a>\n```\n\n## Mitigation\n\n* Avoid using the `React.createElement(...)` function directly.\n* Don't use the `dangerouslySetInnerHTML` function on React components.\n* Don't dynamically generate `href` attributes from untrusted content.\n\n:::\n\n:::tab[Scala]\n\n## Template Injection in Scala\n\nThe two most popular template engines in Scala are Twirl, which is used by the Play framework, and Scalate, which \nsupports a variety of templates syntaxes. Both are commonly used to generate dynamic HTML by combining static\ntemplate files with dynamic data. The programmatic instructions within these template files can use the full Scala\nsyntax and typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the templates themselves are generated at runtime. Take a look at \nthis vulnerable code that uses the Scalate library to dynamically create and then evaluate a template string:\n\n```scala\ndef details(username : String, field : String) = Action {\n  val template = new StringTemplateSource(\"file.ssp\", \"<html><h1>${username}</h1><h2>${\" + field + \"}</h2></html>\")\n  val output   = new StringWriter()\n  val context  = new DefaultRenderContext(\"\", engine, new PrintWriter(output))\n\n  val user = User.findByUsername(username)\n\n  for ((key, value) <- user) {\n    context.attributes.update(key, value)\n  }\n\n  engine.compile(template).render(context)\n\n  Ok(output.toString).as(\"text/html\")\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by\nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk. In the \nPlay framework, for example, a Twirl template stored at `/app/views/users/profile.scala.html` can be rendered in an\naction with very simply\n\n```scala\n  def profile(username: String, field: String) = Action {\n    User\n      .findByUsername(username)\n      .map { client =>\n        Ok(views.html.users.profile(user, field))\n      }\n      .getOrElse(NotFound)\n  }\n```\n\nThe template `/app/views/users/profile.scala.html` expects a `User` object and a field name:\n\n```html\n@(user: models.User, field: String)\n<html>\n  <h1>@user.username</h1>\n  <h2>@(user.getField(field))</h2>\n</html>\n```\n\nSince the template is defined on disk there is no risk of dynamically executing malicious content passed by an attacker. \nThis will protect your from template injection attacks.\n\n:::\n\n:::tab[Go]\n\n## Template Injection in Go\n\nDynamic HTML is generally generated in Go using the `html/template` package. Template files can be loaded from disk, or \ntemplate strings can be constructed dynamically. The latter scenario presents some risks, as illustrated by the \nfollowing code:\n\n```go\nimport (\n  \"github.com/gorilla/mux\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n)\n\n// Start up a new web server.\nfunc main() {\n  routes := mux.NewRouter()\n  \n  // Add a route to the profile handler.\n  routes.HandleFunc(\"/user/{username}/{field}\", ProfileDataHandler)\n\n  log.Fatal(http.ListenAndServe(\":8000\", routes))\n}\n\n// Render a user's profile.\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  \n  // Load the user referenced in the URL path.\n  user := loadUser(vars[\"username\"])\n\n  // Dynamically generating the template using string concatenation is very dangerous!\n  templateString := `<div>\n                       <h1> {{ .Username }}</h1>\n                       <p>  {{ .` + strings.Title(vars[\"field\"]) + ` }} </p>\n                     </div>`\n\n  // Render the template.\n  template, err := template.New(\"profile\").Parse(templateString)\n\n  if err != nil {\n    http.Error(response, \"Error parsing template\", http.StatusInternalServerError)\n    return\n  }\n\n  // Return the generated HTML.\n  template.Execute(response, user)\n}\n```\n\nThis routing logic is intended to take a path like `/users/username/email` and look up the \"Email\" field on that \nparticular user. However, since the third part of the path is concatenated into the template string - notice the `+` \ncharacters - the `field` parameter will may also get evaluated as a method call on the `User` object. Depending on \nwhich methods are defined on the the `User` object, this potentially gives an attacker a backdoor method of executing\ncode on your web-server.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```go\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  user := loadUser(vars[\"username\"])\n\n  // Load the template from disk.\n  template, err := template.ParseFiles(\"templates/profile.html\")\n\n  // Prepare the user data we wish to render.\n  data := UserData{\n    Username:     user.Username,\n    ProfileField: user.GetField(vars[\"field\"])\n  }\n  \n  template.Execute(response, data)\n}\n```\n\nThe template file `templates/profile.html` will look like this:\n\n```html\n<div>\n  <h1> {{ .Username     }} </h1>\n  <p>  {{ .ProfileField }} </p>\n</div>\n```\n\nSince the template is defined on disk (rather than generated at runtime), an attacker cannot inject dynamic content -\nmeaning you are safe from template injection attacks.\n\n:::\n\n:::tab[PHP]\n\n## Template Injection in PHP\n\nOne of the most commonly used template engines in PHP is Twig. PHP itself has built-in templating capabilities, but more advanced engines like Twig provide more structure and separation of logic from presentation. \n\nIn PHP, a common area of vulnerability is when user input is interpolated directly into the template string. This can lead to template injections if the user input is treated as part of the template logic rather than simple data.\n\nFor example, consider the following vulnerable code snippet:\n\n```php\n<?php\n$username = $_GET['username'];\n$field = $_GET['field'];\n\n$template = \"<div><h1>{{ username }}</h1><p>{{ $field }}</p></div>\";\n\n// Imagine using Twig or another templating engine here\necho $twig->renderString($template, ['username' => $username]);\n?>\n```\n\nIn this code, `$field` is interpolated directly into the template string. A malicious user could craft an input for `field` that would be treated as template logic, leading to unintended code execution.\n\n## Mitigation\n\nTo mitigate template injection attacks in PHP:\n\n1. **Avoid Interpolating User Input Directly**: As a rule, never interpolate user input directly into template strings. Always pass user data as separate context or variables to the template, allowing the engine to handle the data safely.\n\n   ```php\n   $template = \"<div><h1>{{ username }}</h1><p>{{ field }}</p></div>\";\n   echo $twig->renderString($template, ['username' => $username, 'field' => $field]);\n   ```\n\n2. **Escape User Input**: Always escape user input when it's displayed in the template. This will prevent any malicious input from being treated as template code. Many modern templating engines, including Twig, have automatic escaping by default.\n\n3. **Use Built-in Functions**: Instead of creating templates dynamically, utilize built-in functions like `render()` to fetch pre-defined templates and pass data to them. \n\n   ```php\n   echo $twig->render('profile.twig', ['username' => $username, 'field' => $field]);\n   ```\n\n4. **Limit Template Engine Capabilities**: If your template engine allows for it, restrict the functionalities that can be used within templates. For instance, if there's no need for a template to access the filesystem or execute system commands, disable those capabilities.\n\n5. **Update Regularly**: Ensure that your templating engine and all dependencies are regularly updated. This will ensure you have the latest security patches.\n\nBy following these measures, you can significantly reduce the risk of template injection vulnerabilities in your PHP applications.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-79](https://cwe.mitre.org/data/definitions/79.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))**",
                "text": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability.\n\n# Template Injection\n\nIn web design, a *template* is an HTML-like file interspersed with programmatic instructions to be interpreted by the\nweb-server or JavaScript code in the browser at runtime. A template is a *static* file used to generate HTML by \ninterpolating *dynamic* content retrieved from a database or pulled from HTTP. \n\nA **template injection** vulnerability occurs when the dynamic content is treated by the template engine as code to be \nexecuted rather data to be interpolated. This will allow an attacker to execute malicious code on your server or in a \nvictim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Template Injection in Java\n\nThere are a wide variety of template engines in Java which allow interpolation of data, the most commonly used of which\nis Java Server Pages (JSPs). Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code that uses the Pebble template engine:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine engine = new PebbleEngine.Builder().build();\n        \n        PebbleTemplate compiledTemplate = engine.getLiteralTemplate(\n            \"<div><h1>{{username}}</h1><p>{{\" + field + \"}}</p></div>\"\n        );\n\n        Map<String, Object> user = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        compiledTemplate.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Java application:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine        engine   = new PebbleEngine.Builder().build();\n        PebbleTemplate      template = engine.getTemplate(\"profile.tmp\");\n        Map<String, Object> user     = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        template.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\n:::\n\n:::tab[Angular]\n\n## Template Injection in Angular\n\nAngular apps consist of a hierarchical set of components that encapsulate application logic and state information. Each \ncomponent is rendered in the browser using a template that describes the HTML to output for the given state of the\ncomponent. Angular templates will safely interpolate state using the `{{` and `}}` delimiters, and allow components\nto listen for user interactions using event handlers.\n\nA template is attached to a component using the `@Component` decorator. Templates can be specified with the\n`templateUrl` option, which supplies the relative or absolute path of the corresponding template file:\n\n```typescript\n@Component({\n  selector:    'app-login',\n  templateUrl: './login.component.html',\n  styleUrls:   ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplates can also be provided as inline strings using the `template` option:\n\n```typescript\n@Component({\n  selector: 'app-login',\n  template: '<form (ngSubmit)=\"onSubmit()\">' + \n            '<input type=\"text\"     placeholder=\"Username\" [(ngModel)]=\"username\" />' +\n            '<input type=\"password\" placeholder=\"Password\" [(ngModel)]=\"password\" />' +\n            '<button type=\"submit\">Login</button>' + \n            '</form>',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplate inject vulnerabilities occur in Angular when untrusted input is passed to the `template` option - in \nparticular, when the template string is generated by string concatenation:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>' + (window.location.hash || 'Home') + '</h1>'\n})\nexport class HeaderComponent {}\n```\n\nAvoid dynamically generated templates in this fashion. Instead, load the state into your component, and use Angular's\nbuilt-in interpolation logic to safely escape any untrusted content:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>{{ title }}</h1>'\n})\nexport class HeaderComponent {\n  title = ''  \n    \n  ngOnInit() {\n    this.title = window.location.hash || 'Home';\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Template Injection in C#\n\nDynamic web pages in ASP.NET Core are rendered using Razor templates that allow interpolation of C# code into\nHTML markup. Razor templates are typically defined as `.cshtml` files at compile time, but you can also dynamically\ngenerate Razor templates at runtime. This latter scenario presents some risks, however. Consider the following action:\n\n```csharp\n[HttpGet(\"/users/{username}/{field}\")]\npublic ActionResult Profile(string username, string field)\n{\n    var razor = new RazorEngine();\n    \n    // Dynamically constructing a template through string interpolation is very dangerous!\n    var template = razor.Compile<IdentityUserModel>(@\"\n        <h1>@username</h1>\n        <h2>@\" + field + \"</h2>\" \n    );\n\n    // Load the user details.\n    var user = LoadUser(username);\n\n    // Render the template.\n    var result = template.Run(user);\n\n    // Return the generated HTML.\n    return Content(result, \"text/html\");\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), an \nattacker will be able to inject extra tags and dynamic content into the template.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your Razor templates are statically defined, rather than generated \nby string concatenation at runtime. This is the default behavior in ASP.NET, so it's very simple to implement:\n\n```csharp\npublic class UserController : Controller\n{\n    [HttpGet(\"/users/{username}/{field}\")]\n    public IActionResult Profile(string username, string field)\n    {\n        // Load the user details.\n        var user = LoadUser(username);\n\n        // Set the state to pass to the template, in the case using the dynamic \"ViewBag\" model.\n        ViewBag.UserName     = username\n        ViewBag.ProfileField = user.GetField(field)\n\n        // Render the template at /Views/User/Profile.cshtml\n        return View();\n    }\n}\n```\n\nThe Razor template `/Views/User/Profile.cshtml` will look like an HTML page that renders the model we pass in:\n\n```html\n<html>\n  <body>\n    <h1>@ViewBag.UserName</h1>\n    <h2>@ViewBag.ProfileField</h2>\n  </body>\n</html>\n```\n\nSince the template is defined on disk, and since the names of the HTML tags are *not* dynamically generated, you are\nprotected from template injection.\n\n:::\n\n:::tab[JavaScript]\n\n## Template Injection in JavaScript\n\nThere are a wide variety of template engines in Node.js which allow interpolation of data, as well as language-native\ntemplate literal strings. Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code:\n\n```javascript\n// Load the EJS template engine.\nconst ejs     = require('ejs')\nconst express = require('express')\n\nconst app = express()\n\napp.get('/:username/:field*', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n  const field     = request.params.field\n\n  const template = `\n    <div>\n      <h1> <%= username %> </h1>\n      <p>  <%= ` + field + ` %> </p>\n    </div>`\n\n  response.send(\n    ejs.render(template, user)\n  )\n})\n```\n\nThis function is intended to take a path like `/username/email` and look up the \"email\" field on that particular user. \nHowever, since the second part of the path is concatenated into the template string (notice the `+` characters), a URL\nlike `/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. Performing a \nsimple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure out how to \nrun commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Express application:\n  \n```javascript\n// Load the 'mustache' template engine.\nconst mustache = require('mustache-express')\nconst express  = require('express')\n\nconst app = express()\n\n// Register the .ms extension for mustache template files.\napp.engine('ms', mustache())\n\n// Register the 'mustache' library as our template engine, tell Express to look for\n// templates in the /views directory.\napp.set('view engine', 'ms')\napp.set('views',       '/views')\n\napp.get('/:username/:field', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n\n  // Render the template '/views/user.ms' using the 'mustache' template engine.\n  response.render('user', {\n    username : username,\n    value    : user[request.params.field]\n  })\n})\n\napp.get('/', (request, response) => {\n  response.render('index', {\n    users: Object.values(users)\n  })\n})\n```\n\nYou should prefer a *less* expressive template engine like `mustache.js` over one like `ejs`. The former tokenizes your \ntemplate files and interpolates data, while the latter uses the `eval(...)` function under the hood. Use of `eval(...)` \nfrequently leads to remote code execution vulnerabilities, as illustrated in our first example.\n\n:::\n\n:::tab[Python]\n\n## Template Injection in Python\n\nThere's a wide variety of templating engines in Python. Jinja2 (the default engine for the Flask web-server) is one of\nthe most popular, and allows easy interpolation of data into HTML. Template files can be loaded from disk, or template\nstrings can be constructed dynamically. The latter scenario presents some risks:\n\n```python\nfrom flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  return render_template_string(\"\"\"\n    <div>\n      <h1> {{ username }} </h1>\n      <p>  {{ \"\"\" + field + \"\"\" }} </p>\n    </div>\n  \"\"\", username=username, field=user.get(field, 'No data'))\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  # Since the template is loaded from disk, we can be sure it is statically defined.\n  return render_template('profile.html', \n                         username = username, \n                         field    = user.get(field, 'No data'))\n```\n\n:::\n\n:::tab[React]\n\n## Template Injection in React\n\nMost React developers use JSX to make HTML tags native in JavaScript syntax. JSX makes it easy to dynamically render \npage elements that correspond to data loaded from the server.\n\nProviding all React components are defined in JSX when the code is transpiled to JavaScript during the build process, \nyou are generally safe from template injection attacks. However, React components *can* be generated directly from the \nlow-level APIs at runtime using the `React.createElement(...)` function. If you invoke this method using untrusted \ncontent, you are vulnerable to template injection attacks:\n\n```jsx\nconst tagName     = 'div'\nconst attributes  = { class: 'page-contents' }\nconst textContent = 'Tag contents go here'\n\n/**\n * Dynamically create a React component, in this case:\n * \n *   <div class=\"page-contents\">Tag contents go here</div>\n *   \n * If any of the arguments come from an untrusted source an attacker can inject malicious content.\n */\nReact.createElement(\n  tagName,\n  attributes,\n  textContent\n)\n```\n\nAttackers can also control the attributes and contents of HTML tags if you invoke the `dangerouslySetInnerHTML` \nfunction on a React component:\n\n```jsx\n/**\n * React allows you to write raw HTML from a string, but discourages it - hence the function name\n * \"dangerouslySetInnerHTML(...)\"! If the inputs to this function are taken from an untrusted source\n * you are vulnerable to template injection.\n */\nconst html = { \n  __html: '<div class=\"page-contents\">Tag contents go here</div>' \n}\n<div dangerouslySetInnerHTML={html} />\n```\n\nThe final source of template injection vulnerabilities in React is `href` attributes. If the `href` attribute of a link \nor import statements is dynamically generated from untrusted content, an attacker can inject JavaScript by supplying a \nURL with a `javascript:` prefix:\n\n```jsx\n/**\n * Dynamically setting the `href` of a link can permit cross-site scripting attacks if the  \n * URL is taken from an untrusted source.\n */\nconst link = \"javascript:alert('Oh no')\"\n    \n// An user clicking on this this component will execute the attacker's JavaScript.\nconst button = <a href={link}>Click here</a>\n```\n\n## Mitigation\n\n* Avoid using the `React.createElement(...)` function directly.\n* Don't use the `dangerouslySetInnerHTML` function on React components.\n* Don't dynamically generate `href` attributes from untrusted content.\n\n:::\n\n:::tab[Scala]\n\n## Template Injection in Scala\n\nThe two most popular template engines in Scala are Twirl, which is used by the Play framework, and Scalate, which \nsupports a variety of templates syntaxes. Both are commonly used to generate dynamic HTML by combining static\ntemplate files with dynamic data. The programmatic instructions within these template files can use the full Scala\nsyntax and typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the templates themselves are generated at runtime. Take a look at \nthis vulnerable code that uses the Scalate library to dynamically create and then evaluate a template string:\n\n```scala\ndef details(username : String, field : String) = Action {\n  val template = new StringTemplateSource(\"file.ssp\", \"<html><h1>${username}</h1><h2>${\" + field + \"}</h2></html>\")\n  val output   = new StringWriter()\n  val context  = new DefaultRenderContext(\"\", engine, new PrintWriter(output))\n\n  val user = User.findByUsername(username)\n\n  for ((key, value) <- user) {\n    context.attributes.update(key, value)\n  }\n\n  engine.compile(template).render(context)\n\n  Ok(output.toString).as(\"text/html\")\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by\nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk. In the \nPlay framework, for example, a Twirl template stored at `/app/views/users/profile.scala.html` can be rendered in an\naction with very simply\n\n```scala\n  def profile(username: String, field: String) = Action {\n    User\n      .findByUsername(username)\n      .map { client =>\n        Ok(views.html.users.profile(user, field))\n      }\n      .getOrElse(NotFound)\n  }\n```\n\nThe template `/app/views/users/profile.scala.html` expects a `User` object and a field name:\n\n```html\n@(user: models.User, field: String)\n<html>\n  <h1>@user.username</h1>\n  <h2>@(user.getField(field))</h2>\n</html>\n```\n\nSince the template is defined on disk there is no risk of dynamically executing malicious content passed by an attacker. \nThis will protect your from template injection attacks.\n\n:::\n\n:::tab[Go]\n\n## Template Injection in Go\n\nDynamic HTML is generally generated in Go using the `html/template` package. Template files can be loaded from disk, or \ntemplate strings can be constructed dynamically. The latter scenario presents some risks, as illustrated by the \nfollowing code:\n\n```go\nimport (\n  \"github.com/gorilla/mux\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n)\n\n// Start up a new web server.\nfunc main() {\n  routes := mux.NewRouter()\n  \n  // Add a route to the profile handler.\n  routes.HandleFunc(\"/user/{username}/{field}\", ProfileDataHandler)\n\n  log.Fatal(http.ListenAndServe(\":8000\", routes))\n}\n\n// Render a user's profile.\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  \n  // Load the user referenced in the URL path.\n  user := loadUser(vars[\"username\"])\n\n  // Dynamically generating the template using string concatenation is very dangerous!\n  templateString := `<div>\n                       <h1> {{ .Username }}</h1>\n                       <p>  {{ .` + strings.Title(vars[\"field\"]) + ` }} </p>\n                     </div>`\n\n  // Render the template.\n  template, err := template.New(\"profile\").Parse(templateString)\n\n  if err != nil {\n    http.Error(response, \"Error parsing template\", http.StatusInternalServerError)\n    return\n  }\n\n  // Return the generated HTML.\n  template.Execute(response, user)\n}\n```\n\nThis routing logic is intended to take a path like `/users/username/email` and look up the \"Email\" field on that \nparticular user. However, since the third part of the path is concatenated into the template string - notice the `+` \ncharacters - the `field` parameter will may also get evaluated as a method call on the `User` object. Depending on \nwhich methods are defined on the the `User` object, this potentially gives an attacker a backdoor method of executing\ncode on your web-server.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```go\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  user := loadUser(vars[\"username\"])\n\n  // Load the template from disk.\n  template, err := template.ParseFiles(\"templates/profile.html\")\n\n  // Prepare the user data we wish to render.\n  data := UserData{\n    Username:     user.Username,\n    ProfileField: user.GetField(vars[\"field\"])\n  }\n  \n  template.Execute(response, data)\n}\n```\n\nThe template file `templates/profile.html` will look like this:\n\n```html\n<div>\n  <h1> {{ .Username     }} </h1>\n  <p>  {{ .ProfileField }} </p>\n</div>\n```\n\nSince the template is defined on disk (rather than generated at runtime), an attacker cannot inject dynamic content -\nmeaning you are safe from template injection attacks.\n\n:::\n\n:::tab[PHP]\n\n## Template Injection in PHP\n\nOne of the most commonly used template engines in PHP is Twig. PHP itself has built-in templating capabilities, but more advanced engines like Twig provide more structure and separation of logic from presentation. \n\nIn PHP, a common area of vulnerability is when user input is interpolated directly into the template string. This can lead to template injections if the user input is treated as part of the template logic rather than simple data.\n\nFor example, consider the following vulnerable code snippet:\n\n```php\n<?php\n$username = $_GET['username'];\n$field = $_GET['field'];\n\n$template = \"<div><h1>{{ username }}</h1><p>{{ $field }}</p></div>\";\n\n// Imagine using Twig or another templating engine here\necho $twig->renderString($template, ['username' => $username]);\n?>\n```\n\nIn this code, `$field` is interpolated directly into the template string. A malicious user could craft an input for `field` that would be treated as template logic, leading to unintended code execution.\n\n## Mitigation\n\nTo mitigate template injection attacks in PHP:\n\n1. **Avoid Interpolating User Input Directly**: As a rule, never interpolate user input directly into template strings. Always pass user data as separate context or variables to the template, allowing the engine to handle the data safely.\n\n   ```php\n   $template = \"<div><h1>{{ username }}</h1><p>{{ field }}</p></div>\";\n   echo $twig->renderString($template, ['username' => $username, 'field' => $field]);\n   ```\n\n2. **Escape User Input**: Always escape user input when it's displayed in the template. This will prevent any malicious input from being treated as template code. Many modern templating engines, including Twig, have automatic escaping by default.\n\n3. **Use Built-in Functions**: Instead of creating templates dynamically, utilize built-in functions like `render()` to fetch pre-defined templates and pass data to them. \n\n   ```php\n   echo $twig->render('profile.twig', ['username' => $username, 'field' => $field]);\n   ```\n\n4. **Limit Template Engine Capabilities**: If your template engine allows for it, restrict the functionalities that can be used within templates. For instance, if there's no need for a template to access the filesystem or execute system commands, disable those capabilities.\n\n5. **Update Regularly**: Ensure that your templating engine and all dependencies are regularly updated. This will ensure you have the latest security patches.\n\nBy following these measures, you can significantly reduce the risk of template injection vulnerabilities in your PHP applications.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-79](https://cwe.mitre.org/data/definitions/79.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a7-Cross-Site_Scripting_(XSS)",
              "id": "xss-to-html-template/e4f937181fa15f5828f1ebbdd97ef9e6",
              "name": "Template Injection: Http Data Used In Html Template Via R In Xss1handler",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 79",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a7-xss",
                  "Template Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Template Injection: HTTP Data Used in HTML Template via r in xss1Handler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1."
              },
              "help": {
                "markdown": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**",
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure",
              "id": "weak-hash/17b4f6dcd42026aecb2356eb386b38ea",
              "name": "Weak Hash: Usage Of Weak Cryptographic Hash Function In Md5sum",
              "properties": {
                "precision": "very-high",
                "security-severity": "3",
                "tags": [
                  "CVSS 3",
                  "CWE 327",
                  "CWE 328",
                  "OWASP 2021 a02-cryptographic-failures",
                  "OWASP a02-2021-cryptographic-failures",
                  "OWASP a3-sensitive-data-exposure",
                  "Weak Hash",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Weak Hash: Usage of Weak Cryptographic Hash Function in Md5Sum"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/c4fd969f383f8341d8b01e5f8a9d517e",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Capturepanic@1",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in CapturePanic@1"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1."
              },
              "help": {
                "markdown": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**",
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure",
              "id": "weak-hash/e6357875527fc2fdfa7f37273c076476",
              "name": "Weak Hash: Usage Of Weak Cryptographic Hash Function In Md5sum",
              "properties": {
                "precision": "very-high",
                "security-severity": "3",
                "tags": [
                  "CVSS 3",
                  "CWE 327",
                  "CWE 328",
                  "OWASP 2021 a02-cryptographic-failures",
                  "OWASP a02-2021-cryptographic-failures",
                  "OWASP a3-sensitive-data-exposure",
                  "Weak Hash",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Weak Hash: Usage of Weak Cryptographic Hash Function in Md5Sum"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability."
              },
              "help": {
                "markdown": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection",
              "id": "sql-injection-attacker-controlled/9cf3e1cbe47ecf4916466cbd4a0536eb",
              "name": "Sql Injection: Attacker-Controlled Data Used In Sql Query Via R In Sqli1handler",
              "properties": {
                "precision": "very-high",
                "security-severity": "9",
                "tags": [
                  "CVSS 9",
                  "CWE 89",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a1-injection",
                  "SQL Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "SQL Injection: Attacker-controlled Data Used in SQL Query via r in sqli1Handler"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "note",
                "rank": -1
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "help": {
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)",
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
              "id": "log-forging-attacker/ef0d7f50a5dea7592da787b4f3089581",
              "name": "Log Forging: Attacker-Controlled Data Is Written Directly To Log Via R In Authcheck@1",
              "properties": {
                "precision": "very-high",
                "security-severity": "2.5",
                "tags": [
                  "CVSS 2.5",
                  "CWE 117",
                  "Log Forging",
                  "OWASP 2021 a09-security-logging-and-monitoring-failures",
                  "OWASP a09-2021-security-logging-and-monitoring-failures",
                  "OWASP a1-injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via r in AuthCheck@1"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning",
                "rank": -1
              },
              "fullDescription": {
                "text": "The Access-Control-Allow-Origin (CORS) header is set to the `\"*\"` wildcard, allowing."
              },
              "help": {
                "markdown": "The Access-Control-Allow-Origin (CORS) header is set to the `\"*\"` wildcard, allowing\ncross-site requests from untrusted third-party web sites. This opts out of standard protections against Cross-Site Request Forgery attacks.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)",
                "text": "The Access-Control-Allow-Origin (CORS) header is set to the `\"*\"` wildcard, allowing\ncross-site requests from untrusted third-party web sites. This opts out of standard protections against Cross-Site Request Forgery attacks.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a6-Security_Misconfiguration",
              "id": "cors-allowAll-httpHeader/3589d17ed495f053bc9590c9d1567e0b",
              "name": "Cross-Site Request Forgery: Overly Permissive Cors Policy In Renderasjson",
              "properties": {
                "precision": "very-high",
                "security-severity": "4",
                "tags": [
                  "CVSS 4",
                  "CWE 942",
                  "Cross-Site Request Forgery",
                  "OWASP 2021 a05-security-misconfiguration",
                  "OWASP a05-2021-security-misconfiguration",
                  "OWASP a6-security-misconfiguration",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in RenderAsJson"
              }
            },
            {
              "defaultConfiguration": {
                "enabled": true,
                "level": "error",
                "rank": -1
              },
              "fullDescription": {
                "text": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability."
              },
              "help": {
                "markdown": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability.\n\n# Template Injection\n\nIn web design, a *template* is an HTML-like file interspersed with programmatic instructions to be interpreted by the\nweb-server or JavaScript code in the browser at runtime. A template is a *static* file used to generate HTML by \ninterpolating *dynamic* content retrieved from a database or pulled from HTTP. \n\nA **template injection** vulnerability occurs when the dynamic content is treated by the template engine as code to be \nexecuted rather data to be interpolated. This will allow an attacker to execute malicious code on your server or in a \nvictim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Template Injection in Java\n\nThere are a wide variety of template engines in Java which allow interpolation of data, the most commonly used of which\nis Java Server Pages (JSPs). Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code that uses the Pebble template engine:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine engine = new PebbleEngine.Builder().build();\n        \n        PebbleTemplate compiledTemplate = engine.getLiteralTemplate(\n            \"<div><h1>{{username}}</h1><p>{{\" + field + \"}}</p></div>\"\n        );\n\n        Map<String, Object> user = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        compiledTemplate.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Java application:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine        engine   = new PebbleEngine.Builder().build();\n        PebbleTemplate      template = engine.getTemplate(\"profile.tmp\");\n        Map<String, Object> user     = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        template.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\n:::\n\n:::tab[Angular]\n\n## Template Injection in Angular\n\nAngular apps consist of a hierarchical set of components that encapsulate application logic and state information. Each \ncomponent is rendered in the browser using a template that describes the HTML to output for the given state of the\ncomponent. Angular templates will safely interpolate state using the `{{` and `}}` delimiters, and allow components\nto listen for user interactions using event handlers.\n\nA template is attached to a component using the `@Component` decorator. Templates can be specified with the\n`templateUrl` option, which supplies the relative or absolute path of the corresponding template file:\n\n```typescript\n@Component({\n  selector:    'app-login',\n  templateUrl: './login.component.html',\n  styleUrls:   ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplates can also be provided as inline strings using the `template` option:\n\n```typescript\n@Component({\n  selector: 'app-login',\n  template: '<form (ngSubmit)=\"onSubmit()\">' + \n            '<input type=\"text\"     placeholder=\"Username\" [(ngModel)]=\"username\" />' +\n            '<input type=\"password\" placeholder=\"Password\" [(ngModel)]=\"password\" />' +\n            '<button type=\"submit\">Login</button>' + \n            '</form>',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplate inject vulnerabilities occur in Angular when untrusted input is passed to the `template` option - in \nparticular, when the template string is generated by string concatenation:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>' + (window.location.hash || 'Home') + '</h1>'\n})\nexport class HeaderComponent {}\n```\n\nAvoid dynamically generated templates in this fashion. Instead, load the state into your component, and use Angular's\nbuilt-in interpolation logic to safely escape any untrusted content:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>{{ title }}</h1>'\n})\nexport class HeaderComponent {\n  title = ''  \n    \n  ngOnInit() {\n    this.title = window.location.hash || 'Home';\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Template Injection in C#\n\nDynamic web pages in ASP.NET Core are rendered using Razor templates that allow interpolation of C# code into\nHTML markup. Razor templates are typically defined as `.cshtml` files at compile time, but you can also dynamically\ngenerate Razor templates at runtime. This latter scenario presents some risks, however. Consider the following action:\n\n```csharp\n[HttpGet(\"/users/{username}/{field}\")]\npublic ActionResult Profile(string username, string field)\n{\n    var razor = new RazorEngine();\n    \n    // Dynamically constructing a template through string interpolation is very dangerous!\n    var template = razor.Compile<IdentityUserModel>(@\"\n        <h1>@username</h1>\n        <h2>@\" + field + \"</h2>\" \n    );\n\n    // Load the user details.\n    var user = LoadUser(username);\n\n    // Render the template.\n    var result = template.Run(user);\n\n    // Return the generated HTML.\n    return Content(result, \"text/html\");\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), an \nattacker will be able to inject extra tags and dynamic content into the template.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your Razor templates are statically defined, rather than generated \nby string concatenation at runtime. This is the default behavior in ASP.NET, so it's very simple to implement:\n\n```csharp\npublic class UserController : Controller\n{\n    [HttpGet(\"/users/{username}/{field}\")]\n    public IActionResult Profile(string username, string field)\n    {\n        // Load the user details.\n        var user = LoadUser(username);\n\n        // Set the state to pass to the template, in the case using the dynamic \"ViewBag\" model.\n        ViewBag.UserName     = username\n        ViewBag.ProfileField = user.GetField(field)\n\n        // Render the template at /Views/User/Profile.cshtml\n        return View();\n    }\n}\n```\n\nThe Razor template `/Views/User/Profile.cshtml` will look like an HTML page that renders the model we pass in:\n\n```html\n<html>\n  <body>\n    <h1>@ViewBag.UserName</h1>\n    <h2>@ViewBag.ProfileField</h2>\n  </body>\n</html>\n```\n\nSince the template is defined on disk, and since the names of the HTML tags are *not* dynamically generated, you are\nprotected from template injection.\n\n:::\n\n:::tab[JavaScript]\n\n## Template Injection in JavaScript\n\nThere are a wide variety of template engines in Node.js which allow interpolation of data, as well as language-native\ntemplate literal strings. Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code:\n\n```javascript\n// Load the EJS template engine.\nconst ejs     = require('ejs')\nconst express = require('express')\n\nconst app = express()\n\napp.get('/:username/:field*', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n  const field     = request.params.field\n\n  const template = `\n    <div>\n      <h1> <%= username %> </h1>\n      <p>  <%= ` + field + ` %> </p>\n    </div>`\n\n  response.send(\n    ejs.render(template, user)\n  )\n})\n```\n\nThis function is intended to take a path like `/username/email` and look up the \"email\" field on that particular user. \nHowever, since the second part of the path is concatenated into the template string (notice the `+` characters), a URL\nlike `/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. Performing a \nsimple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure out how to \nrun commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Express application:\n  \n```javascript\n// Load the 'mustache' template engine.\nconst mustache = require('mustache-express')\nconst express  = require('express')\n\nconst app = express()\n\n// Register the .ms extension for mustache template files.\napp.engine('ms', mustache())\n\n// Register the 'mustache' library as our template engine, tell Express to look for\n// templates in the /views directory.\napp.set('view engine', 'ms')\napp.set('views',       '/views')\n\napp.get('/:username/:field', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n\n  // Render the template '/views/user.ms' using the 'mustache' template engine.\n  response.render('user', {\n    username : username,\n    value    : user[request.params.field]\n  })\n})\n\napp.get('/', (request, response) => {\n  response.render('index', {\n    users: Object.values(users)\n  })\n})\n```\n\nYou should prefer a *less* expressive template engine like `mustache.js` over one like `ejs`. The former tokenizes your \ntemplate files and interpolates data, while the latter uses the `eval(...)` function under the hood. Use of `eval(...)` \nfrequently leads to remote code execution vulnerabilities, as illustrated in our first example.\n\n:::\n\n:::tab[Python]\n\n## Template Injection in Python\n\nThere's a wide variety of templating engines in Python. Jinja2 (the default engine for the Flask web-server) is one of\nthe most popular, and allows easy interpolation of data into HTML. Template files can be loaded from disk, or template\nstrings can be constructed dynamically. The latter scenario presents some risks:\n\n```python\nfrom flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  return render_template_string(\"\"\"\n    <div>\n      <h1> {{ username }} </h1>\n      <p>  {{ \"\"\" + field + \"\"\" }} </p>\n    </div>\n  \"\"\", username=username, field=user.get(field, 'No data'))\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  # Since the template is loaded from disk, we can be sure it is statically defined.\n  return render_template('profile.html', \n                         username = username, \n                         field    = user.get(field, 'No data'))\n```\n\n:::\n\n:::tab[React]\n\n## Template Injection in React\n\nMost React developers use JSX to make HTML tags native in JavaScript syntax. JSX makes it easy to dynamically render \npage elements that correspond to data loaded from the server.\n\nProviding all React components are defined in JSX when the code is transpiled to JavaScript during the build process, \nyou are generally safe from template injection attacks. However, React components *can* be generated directly from the \nlow-level APIs at runtime using the `React.createElement(...)` function. If you invoke this method using untrusted \ncontent, you are vulnerable to template injection attacks:\n\n```jsx\nconst tagName     = 'div'\nconst attributes  = { class: 'page-contents' }\nconst textContent = 'Tag contents go here'\n\n/**\n * Dynamically create a React component, in this case:\n * \n *   <div class=\"page-contents\">Tag contents go here</div>\n *   \n * If any of the arguments come from an untrusted source an attacker can inject malicious content.\n */\nReact.createElement(\n  tagName,\n  attributes,\n  textContent\n)\n```\n\nAttackers can also control the attributes and contents of HTML tags if you invoke the `dangerouslySetInnerHTML` \nfunction on a React component:\n\n```jsx\n/**\n * React allows you to write raw HTML from a string, but discourages it - hence the function name\n * \"dangerouslySetInnerHTML(...)\"! If the inputs to this function are taken from an untrusted source\n * you are vulnerable to template injection.\n */\nconst html = { \n  __html: '<div class=\"page-contents\">Tag contents go here</div>' \n}\n<div dangerouslySetInnerHTML={html} />\n```\n\nThe final source of template injection vulnerabilities in React is `href` attributes. If the `href` attribute of a link \nor import statements is dynamically generated from untrusted content, an attacker can inject JavaScript by supplying a \nURL with a `javascript:` prefix:\n\n```jsx\n/**\n * Dynamically setting the `href` of a link can permit cross-site scripting attacks if the  \n * URL is taken from an untrusted source.\n */\nconst link = \"javascript:alert('Oh no')\"\n    \n// An user clicking on this this component will execute the attacker's JavaScript.\nconst button = <a href={link}>Click here</a>\n```\n\n## Mitigation\n\n* Avoid using the `React.createElement(...)` function directly.\n* Don't use the `dangerouslySetInnerHTML` function on React components.\n* Don't dynamically generate `href` attributes from untrusted content.\n\n:::\n\n:::tab[Scala]\n\n## Template Injection in Scala\n\nThe two most popular template engines in Scala are Twirl, which is used by the Play framework, and Scalate, which \nsupports a variety of templates syntaxes. Both are commonly used to generate dynamic HTML by combining static\ntemplate files with dynamic data. The programmatic instructions within these template files can use the full Scala\nsyntax and typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the templates themselves are generated at runtime. Take a look at \nthis vulnerable code that uses the Scalate library to dynamically create and then evaluate a template string:\n\n```scala\ndef details(username : String, field : String) = Action {\n  val template = new StringTemplateSource(\"file.ssp\", \"<html><h1>${username}</h1><h2>${\" + field + \"}</h2></html>\")\n  val output   = new StringWriter()\n  val context  = new DefaultRenderContext(\"\", engine, new PrintWriter(output))\n\n  val user = User.findByUsername(username)\n\n  for ((key, value) <- user) {\n    context.attributes.update(key, value)\n  }\n\n  engine.compile(template).render(context)\n\n  Ok(output.toString).as(\"text/html\")\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by\nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk. In the \nPlay framework, for example, a Twirl template stored at `/app/views/users/profile.scala.html` can be rendered in an\naction with very simply\n\n```scala\n  def profile(username: String, field: String) = Action {\n    User\n      .findByUsername(username)\n      .map { client =>\n        Ok(views.html.users.profile(user, field))\n      }\n      .getOrElse(NotFound)\n  }\n```\n\nThe template `/app/views/users/profile.scala.html` expects a `User` object and a field name:\n\n```html\n@(user: models.User, field: String)\n<html>\n  <h1>@user.username</h1>\n  <h2>@(user.getField(field))</h2>\n</html>\n```\n\nSince the template is defined on disk there is no risk of dynamically executing malicious content passed by an attacker. \nThis will protect your from template injection attacks.\n\n:::\n\n:::tab[Go]\n\n## Template Injection in Go\n\nDynamic HTML is generally generated in Go using the `html/template` package. Template files can be loaded from disk, or \ntemplate strings can be constructed dynamically. The latter scenario presents some risks, as illustrated by the \nfollowing code:\n\n```go\nimport (\n  \"github.com/gorilla/mux\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n)\n\n// Start up a new web server.\nfunc main() {\n  routes := mux.NewRouter()\n  \n  // Add a route to the profile handler.\n  routes.HandleFunc(\"/user/{username}/{field}\", ProfileDataHandler)\n\n  log.Fatal(http.ListenAndServe(\":8000\", routes))\n}\n\n// Render a user's profile.\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  \n  // Load the user referenced in the URL path.\n  user := loadUser(vars[\"username\"])\n\n  // Dynamically generating the template using string concatenation is very dangerous!\n  templateString := `<div>\n                       <h1> {{ .Username }}</h1>\n                       <p>  {{ .` + strings.Title(vars[\"field\"]) + ` }} </p>\n                     </div>`\n\n  // Render the template.\n  template, err := template.New(\"profile\").Parse(templateString)\n\n  if err != nil {\n    http.Error(response, \"Error parsing template\", http.StatusInternalServerError)\n    return\n  }\n\n  // Return the generated HTML.\n  template.Execute(response, user)\n}\n```\n\nThis routing logic is intended to take a path like `/users/username/email` and look up the \"Email\" field on that \nparticular user. However, since the third part of the path is concatenated into the template string - notice the `+` \ncharacters - the `field` parameter will may also get evaluated as a method call on the `User` object. Depending on \nwhich methods are defined on the the `User` object, this potentially gives an attacker a backdoor method of executing\ncode on your web-server.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```go\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  user := loadUser(vars[\"username\"])\n\n  // Load the template from disk.\n  template, err := template.ParseFiles(\"templates/profile.html\")\n\n  // Prepare the user data we wish to render.\n  data := UserData{\n    Username:     user.Username,\n    ProfileField: user.GetField(vars[\"field\"])\n  }\n  \n  template.Execute(response, data)\n}\n```\n\nThe template file `templates/profile.html` will look like this:\n\n```html\n<div>\n  <h1> {{ .Username     }} </h1>\n  <p>  {{ .ProfileField }} </p>\n</div>\n```\n\nSince the template is defined on disk (rather than generated at runtime), an attacker cannot inject dynamic content -\nmeaning you are safe from template injection attacks.\n\n:::\n\n:::tab[PHP]\n\n## Template Injection in PHP\n\nOne of the most commonly used template engines in PHP is Twig. PHP itself has built-in templating capabilities, but more advanced engines like Twig provide more structure and separation of logic from presentation. \n\nIn PHP, a common area of vulnerability is when user input is interpolated directly into the template string. This can lead to template injections if the user input is treated as part of the template logic rather than simple data.\n\nFor example, consider the following vulnerable code snippet:\n\n```php\n<?php\n$username = $_GET['username'];\n$field = $_GET['field'];\n\n$template = \"<div><h1>{{ username }}</h1><p>{{ $field }}</p></div>\";\n\n// Imagine using Twig or another templating engine here\necho $twig->renderString($template, ['username' => $username]);\n?>\n```\n\nIn this code, `$field` is interpolated directly into the template string. A malicious user could craft an input for `field` that would be treated as template logic, leading to unintended code execution.\n\n## Mitigation\n\nTo mitigate template injection attacks in PHP:\n\n1. **Avoid Interpolating User Input Directly**: As a rule, never interpolate user input directly into template strings. Always pass user data as separate context or variables to the template, allowing the engine to handle the data safely.\n\n   ```php\n   $template = \"<div><h1>{{ username }}</h1><p>{{ field }}</p></div>\";\n   echo $twig->renderString($template, ['username' => $username, 'field' => $field]);\n   ```\n\n2. **Escape User Input**: Always escape user input when it's displayed in the template. This will prevent any malicious input from being treated as template code. Many modern templating engines, including Twig, have automatic escaping by default.\n\n3. **Use Built-in Functions**: Instead of creating templates dynamically, utilize built-in functions like `render()` to fetch pre-defined templates and pass data to them. \n\n   ```php\n   echo $twig->render('profile.twig', ['username' => $username, 'field' => $field]);\n   ```\n\n4. **Limit Template Engine Capabilities**: If your template engine allows for it, restrict the functionalities that can be used within templates. For instance, if there's no need for a template to access the filesystem or execute system commands, disable those capabilities.\n\n5. **Update Regularly**: Ensure that your templating engine and all dependencies are regularly updated. This will ensure you have the latest security patches.\n\nBy following these measures, you can significantly reduce the risk of template injection vulnerabilities in your PHP applications.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-79](https://cwe.mitre.org/data/definitions/79.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))**",
                "text": "Data from a HTTP request or response is used in HTML rendering. This indicates a template injection vulnerability.\n\n# Template Injection\n\nIn web design, a *template* is an HTML-like file interspersed with programmatic instructions to be interpreted by the\nweb-server or JavaScript code in the browser at runtime. A template is a *static* file used to generate HTML by \ninterpolating *dynamic* content retrieved from a database or pulled from HTTP. \n\nA **template injection** vulnerability occurs when the dynamic content is treated by the template engine as code to be \nexecuted rather data to be interpolated. This will allow an attacker to execute malicious code on your server or in a \nvictim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Template Injection in Java\n\nThere are a wide variety of template engines in Java which allow interpolation of data, the most commonly used of which\nis Java Server Pages (JSPs). Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code that uses the Pebble template engine:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine engine = new PebbleEngine.Builder().build();\n        \n        PebbleTemplate compiledTemplate = engine.getLiteralTemplate(\n            \"<div><h1>{{username}}</h1><p>{{\" + field + \"}}</p></div>\"\n        );\n\n        Map<String, Object> user = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        compiledTemplate.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Java application:\n\n```java\n@Path(\"/{username}\")\npublic class UserProfile\n{\n    @GET\n    @Path(\"/{field}\")\n    @Produces(\"text/html\")\n    public Response details(@PathParam(\"username\") final String username,\n                            @PathParam(\"field\")    final String field) throws IOException\n    {\n        PebbleEngine        engine   = new PebbleEngine.Builder().build();\n        PebbleTemplate      template = engine.getTemplate(\"profile.tmp\");\n        Map<String, Object> user     = getDatabase().getUser(username);\n\n        Writer writer = new StringWriter();\n        template.evaluate(writer, user);\n\n        return Response.ok().entity(writer.toString()).build();\n    }\n}\n```\n\n:::\n\n:::tab[Angular]\n\n## Template Injection in Angular\n\nAngular apps consist of a hierarchical set of components that encapsulate application logic and state information. Each \ncomponent is rendered in the browser using a template that describes the HTML to output for the given state of the\ncomponent. Angular templates will safely interpolate state using the `{{` and `}}` delimiters, and allow components\nto listen for user interactions using event handlers.\n\nA template is attached to a component using the `@Component` decorator. Templates can be specified with the\n`templateUrl` option, which supplies the relative or absolute path of the corresponding template file:\n\n```typescript\n@Component({\n  selector:    'app-login',\n  templateUrl: './login.component.html',\n  styleUrls:   ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplates can also be provided as inline strings using the `template` option:\n\n```typescript\n@Component({\n  selector: 'app-login',\n  template: '<form (ngSubmit)=\"onSubmit()\">' + \n            '<input type=\"text\"     placeholder=\"Username\" [(ngModel)]=\"username\" />' +\n            '<input type=\"password\" placeholder=\"Password\" [(ngModel)]=\"password\" />' +\n            '<button type=\"submit\">Login</button>' + \n            '</form>',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {}\n```\n\nTemplate inject vulnerabilities occur in Angular when untrusted input is passed to the `template` option - in \nparticular, when the template string is generated by string concatenation:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>' + (window.location.hash || 'Home') + '</h1>'\n})\nexport class HeaderComponent {}\n```\n\nAvoid dynamically generated templates in this fashion. Instead, load the state into your component, and use Angular's\nbuilt-in interpolation logic to safely escape any untrusted content:\n\n```typescript\n@Component({\n  selector: 'app-header',\n  template: '<h1>{{ title }}</h1>'\n})\nexport class HeaderComponent {\n  title = ''  \n    \n  ngOnInit() {\n    this.title = window.location.hash || 'Home';\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Template Injection in C#\n\nDynamic web pages in ASP.NET Core are rendered using Razor templates that allow interpolation of C# code into\nHTML markup. Razor templates are typically defined as `.cshtml` files at compile time, but you can also dynamically\ngenerate Razor templates at runtime. This latter scenario presents some risks, however. Consider the following action:\n\n```csharp\n[HttpGet(\"/users/{username}/{field}\")]\npublic ActionResult Profile(string username, string field)\n{\n    var razor = new RazorEngine();\n    \n    // Dynamically constructing a template through string interpolation is very dangerous!\n    var template = razor.Compile<IdentityUserModel>(@\"\n        <h1>@username</h1>\n        <h2>@\" + field + \"</h2>\" \n    );\n\n    // Load the user details.\n    var user = LoadUser(username);\n\n    // Render the template.\n    var result = template.Run(user);\n\n    // Return the generated HTML.\n    return Content(result, \"text/html\");\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), an \nattacker will be able to inject extra tags and dynamic content into the template.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your Razor templates are statically defined, rather than generated \nby string concatenation at runtime. This is the default behavior in ASP.NET, so it's very simple to implement:\n\n```csharp\npublic class UserController : Controller\n{\n    [HttpGet(\"/users/{username}/{field}\")]\n    public IActionResult Profile(string username, string field)\n    {\n        // Load the user details.\n        var user = LoadUser(username);\n\n        // Set the state to pass to the template, in the case using the dynamic \"ViewBag\" model.\n        ViewBag.UserName     = username\n        ViewBag.ProfileField = user.GetField(field)\n\n        // Render the template at /Views/User/Profile.cshtml\n        return View();\n    }\n}\n```\n\nThe Razor template `/Views/User/Profile.cshtml` will look like an HTML page that renders the model we pass in:\n\n```html\n<html>\n  <body>\n    <h1>@ViewBag.UserName</h1>\n    <h2>@ViewBag.ProfileField</h2>\n  </body>\n</html>\n```\n\nSince the template is defined on disk, and since the names of the HTML tags are *not* dynamically generated, you are\nprotected from template injection.\n\n:::\n\n:::tab[JavaScript]\n\n## Template Injection in JavaScript\n\nThere are a wide variety of template engines in Node.js which allow interpolation of data, as well as language-native\ntemplate literal strings. Programmatic instructions within a template file typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the template string is generated at runtime. Take a look at this\nvulnerable code:\n\n```javascript\n// Load the EJS template engine.\nconst ejs     = require('ejs')\nconst express = require('express')\n\nconst app = express()\n\napp.get('/:username/:field*', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n  const field     = request.params.field\n\n  const template = `\n    <div>\n      <h1> <%= username %> </h1>\n      <p>  <%= ` + field + ` %> </p>\n    </div>`\n\n  response.send(\n    ejs.render(template, user)\n  )\n})\n```\n\nThis function is intended to take a path like `/username/email` and look up the \"email\" field on that particular user. \nHowever, since the second part of the path is concatenated into the template string (notice the `+` characters), a URL\nlike `/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. Performing a \nsimple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure out how to \nrun commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk, as we see \nwith this Express application:\n  \n```javascript\n// Load the 'mustache' template engine.\nconst mustache = require('mustache-express')\nconst express  = require('express')\n\nconst app = express()\n\n// Register the .ms extension for mustache template files.\napp.engine('ms', mustache())\n\n// Register the 'mustache' library as our template engine, tell Express to look for\n// templates in the /views directory.\napp.set('view engine', 'ms')\napp.set('views',       '/views')\n\napp.get('/:username/:field', (request, response) => {\n  const username  = request.params.username\n  const user      = users[username]\n\n  // Render the template '/views/user.ms' using the 'mustache' template engine.\n  response.render('user', {\n    username : username,\n    value    : user[request.params.field]\n  })\n})\n\napp.get('/', (request, response) => {\n  response.render('index', {\n    users: Object.values(users)\n  })\n})\n```\n\nYou should prefer a *less* expressive template engine like `mustache.js` over one like `ejs`. The former tokenizes your \ntemplate files and interpolates data, while the latter uses the `eval(...)` function under the hood. Use of `eval(...)` \nfrequently leads to remote code execution vulnerabilities, as illustrated in our first example.\n\n:::\n\n:::tab[Python]\n\n## Template Injection in Python\n\nThere's a wide variety of templating engines in Python. Jinja2 (the default engine for the Flask web-server) is one of\nthe most popular, and allows easy interpolation of data into HTML. Template files can be loaded from disk, or template\nstrings can be constructed dynamically. The latter scenario presents some risks:\n\n```python\nfrom flask import Flask, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  return render_template_string(\"\"\"\n    <div>\n      <h1> {{ username }} </h1>\n      <p>  {{ \"\"\" + field + \"\"\" }} </p>\n    </div>\n  \"\"\", username=username, field=user.get(field, 'No data'))\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks, ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/users/<username>/<field>')\ndef profile_data(username, field):\n  user = load_profile(username)\n\n  # Since the template is loaded from disk, we can be sure it is statically defined.\n  return render_template('profile.html', \n                         username = username, \n                         field    = user.get(field, 'No data'))\n```\n\n:::\n\n:::tab[React]\n\n## Template Injection in React\n\nMost React developers use JSX to make HTML tags native in JavaScript syntax. JSX makes it easy to dynamically render \npage elements that correspond to data loaded from the server.\n\nProviding all React components are defined in JSX when the code is transpiled to JavaScript during the build process, \nyou are generally safe from template injection attacks. However, React components *can* be generated directly from the \nlow-level APIs at runtime using the `React.createElement(...)` function. If you invoke this method using untrusted \ncontent, you are vulnerable to template injection attacks:\n\n```jsx\nconst tagName     = 'div'\nconst attributes  = { class: 'page-contents' }\nconst textContent = 'Tag contents go here'\n\n/**\n * Dynamically create a React component, in this case:\n * \n *   <div class=\"page-contents\">Tag contents go here</div>\n *   \n * If any of the arguments come from an untrusted source an attacker can inject malicious content.\n */\nReact.createElement(\n  tagName,\n  attributes,\n  textContent\n)\n```\n\nAttackers can also control the attributes and contents of HTML tags if you invoke the `dangerouslySetInnerHTML` \nfunction on a React component:\n\n```jsx\n/**\n * React allows you to write raw HTML from a string, but discourages it - hence the function name\n * \"dangerouslySetInnerHTML(...)\"! If the inputs to this function are taken from an untrusted source\n * you are vulnerable to template injection.\n */\nconst html = { \n  __html: '<div class=\"page-contents\">Tag contents go here</div>' \n}\n<div dangerouslySetInnerHTML={html} />\n```\n\nThe final source of template injection vulnerabilities in React is `href` attributes. If the `href` attribute of a link \nor import statements is dynamically generated from untrusted content, an attacker can inject JavaScript by supplying a \nURL with a `javascript:` prefix:\n\n```jsx\n/**\n * Dynamically setting the `href` of a link can permit cross-site scripting attacks if the  \n * URL is taken from an untrusted source.\n */\nconst link = \"javascript:alert('Oh no')\"\n    \n// An user clicking on this this component will execute the attacker's JavaScript.\nconst button = <a href={link}>Click here</a>\n```\n\n## Mitigation\n\n* Avoid using the `React.createElement(...)` function directly.\n* Don't use the `dangerouslySetInnerHTML` function on React components.\n* Don't dynamically generate `href` attributes from untrusted content.\n\n:::\n\n:::tab[Scala]\n\n## Template Injection in Scala\n\nThe two most popular template engines in Scala are Twirl, which is used by the Play framework, and Scalate, which \nsupports a variety of templates syntaxes. Both are commonly used to generate dynamic HTML by combining static\ntemplate files with dynamic data. The programmatic instructions within these template files can use the full Scala\nsyntax and typically perform one of three functions:\n\n  * Interpolating dynamic data as the contents of an HTML tag.\n  * Looping over a data structure to repeatedly render a chunk HTML of with differing content values.\n  * Conditionally rendering chunks of HTML depending on the user's identity.\n\nTemplate injection vulnerabilities usually occur when the templates themselves are generated at runtime. Take a look at \nthis vulnerable code that uses the Scalate library to dynamically create and then evaluate a template string:\n\n```scala\ndef details(username : String, field : String) = Action {\n  val template = new StringTemplateSource(\"file.ssp\", \"<html><h1>${username}</h1><h2>${\" + field + \"}</h2></html>\")\n  val output   = new StringWriter()\n  val context  = new DefaultRenderContext(\"\", engine, new PrintWriter(output))\n\n  val user = User.findByUsername(username)\n\n  for ((key, value) <- user) {\n    context.attributes.update(key, value)\n  }\n\n  engine.compile(template).render(context)\n\n  Ok(output.toString).as(\"text/html\")\n}\n```\n\nThis function is intended to take a path like `/users/username/email` and look up the \"email\" field on that particular \nuser. However, since the third part of the path is concatenated into the template string (notice the `+` characters), a \nURL like `/user/username/5*5` will print out \"25\" - the `field` parameter will get evaluated as code at runtime. \nPerforming a simple arithmetic calculation is the least of your worries here - a smart attacker will be able to figure \nout how to run commands on your underlying operating system with a little experimentation.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by\nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk. In the \nPlay framework, for example, a Twirl template stored at `/app/views/users/profile.scala.html` can be rendered in an\naction with very simply\n\n```scala\n  def profile(username: String, field: String) = Action {\n    User\n      .findByUsername(username)\n      .map { client =>\n        Ok(views.html.users.profile(user, field))\n      }\n      .getOrElse(NotFound)\n  }\n```\n\nThe template `/app/views/users/profile.scala.html` expects a `User` object and a field name:\n\n```html\n@(user: models.User, field: String)\n<html>\n  <h1>@user.username</h1>\n  <h2>@(user.getField(field))</h2>\n</html>\n```\n\nSince the template is defined on disk there is no risk of dynamically executing malicious content passed by an attacker. \nThis will protect your from template injection attacks.\n\n:::\n\n:::tab[Go]\n\n## Template Injection in Go\n\nDynamic HTML is generally generated in Go using the `html/template` package. Template files can be loaded from disk, or \ntemplate strings can be constructed dynamically. The latter scenario presents some risks, as illustrated by the \nfollowing code:\n\n```go\nimport (\n  \"github.com/gorilla/mux\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n  \"strings\"\n)\n\n// Start up a new web server.\nfunc main() {\n  routes := mux.NewRouter()\n  \n  // Add a route to the profile handler.\n  routes.HandleFunc(\"/user/{username}/{field}\", ProfileDataHandler)\n\n  log.Fatal(http.ListenAndServe(\":8000\", routes))\n}\n\n// Render a user's profile.\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  \n  // Load the user referenced in the URL path.\n  user := loadUser(vars[\"username\"])\n\n  // Dynamically generating the template using string concatenation is very dangerous!\n  templateString := `<div>\n                       <h1> {{ .Username }}</h1>\n                       <p>  {{ .` + strings.Title(vars[\"field\"]) + ` }} </p>\n                     </div>`\n\n  // Render the template.\n  template, err := template.New(\"profile\").Parse(templateString)\n\n  if err != nil {\n    http.Error(response, \"Error parsing template\", http.StatusInternalServerError)\n    return\n  }\n\n  // Return the generated HTML.\n  template.Execute(response, user)\n}\n```\n\nThis routing logic is intended to take a path like `/users/username/email` and look up the \"Email\" field on that \nparticular user. However, since the third part of the path is concatenated into the template string - notice the `+` \ncharacters - the `field` parameter will may also get evaluated as a method call on the `User` object. Depending on \nwhich methods are defined on the the `User` object, this potentially gives an attacker a backdoor method of executing\ncode on your web-server.\n\n## Mitigation\n\nTo protect against template injection attacks ensure your templates are statically defined, rather than generated by \nstring concatenation at runtime. A good way to achieve this is to have the templates defined as files on disk:\n\n```go\nfunc ProfileDataHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n  user := loadUser(vars[\"username\"])\n\n  // Load the template from disk.\n  template, err := template.ParseFiles(\"templates/profile.html\")\n\n  // Prepare the user data we wish to render.\n  data := UserData{\n    Username:     user.Username,\n    ProfileField: user.GetField(vars[\"field\"])\n  }\n  \n  template.Execute(response, data)\n}\n```\n\nThe template file `templates/profile.html` will look like this:\n\n```html\n<div>\n  <h1> {{ .Username     }} </h1>\n  <p>  {{ .ProfileField }} </p>\n</div>\n```\n\nSince the template is defined on disk (rather than generated at runtime), an attacker cannot inject dynamic content -\nmeaning you are safe from template injection attacks.\n\n:::\n\n:::tab[PHP]\n\n## Template Injection in PHP\n\nOne of the most commonly used template engines in PHP is Twig. PHP itself has built-in templating capabilities, but more advanced engines like Twig provide more structure and separation of logic from presentation. \n\nIn PHP, a common area of vulnerability is when user input is interpolated directly into the template string. This can lead to template injections if the user input is treated as part of the template logic rather than simple data.\n\nFor example, consider the following vulnerable code snippet:\n\n```php\n<?php\n$username = $_GET['username'];\n$field = $_GET['field'];\n\n$template = \"<div><h1>{{ username }}</h1><p>{{ $field }}</p></div>\";\n\n// Imagine using Twig or another templating engine here\necho $twig->renderString($template, ['username' => $username]);\n?>\n```\n\nIn this code, `$field` is interpolated directly into the template string. A malicious user could craft an input for `field` that would be treated as template logic, leading to unintended code execution.\n\n## Mitigation\n\nTo mitigate template injection attacks in PHP:\n\n1. **Avoid Interpolating User Input Directly**: As a rule, never interpolate user input directly into template strings. Always pass user data as separate context or variables to the template, allowing the engine to handle the data safely.\n\n   ```php\n   $template = \"<div><h1>{{ username }}</h1><p>{{ field }}</p></div>\";\n   echo $twig->renderString($template, ['username' => $username, 'field' => $field]);\n   ```\n\n2. **Escape User Input**: Always escape user input when it's displayed in the template. This will prevent any malicious input from being treated as template code. Many modern templating engines, including Twig, have automatic escaping by default.\n\n3. **Use Built-in Functions**: Instead of creating templates dynamically, utilize built-in functions like `render()` to fetch pre-defined templates and pass data to them. \n\n   ```php\n   echo $twig->render('profile.twig', ['username' => $username, 'field' => $field]);\n   ```\n\n4. **Limit Template Engine Capabilities**: If your template engine allows for it, restrict the functionalities that can be used within templates. For instance, if there's no need for a template to access the filesystem or execute system commands, disable those capabilities.\n\n5. **Update Regularly**: Ensure that your templating engine and all dependencies are regularly updated. This will ensure you have the latest security patches.\n\nBy following these measures, you can significantly reduce the risk of template injection vulnerabilities in your PHP applications.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-79](https://cwe.mitre.org/data/definitions/79.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS))**"
              },
              "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a7-Cross-Site_Scripting_(XSS)",
              "id": "xss-to-html-template/8a7f4fa43141cea249c2c55fe57f54d2",
              "name": "Template Injection: Http Data Used In Html Template Via R In Xss1handler",
              "properties": {
                "precision": "very-high",
                "security-severity": "8",
                "tags": [
                  "CVSS 8",
                  "CWE 79",
                  "OWASP 2021 a03-injection",
                  "OWASP a03-2021-injection",
                  "OWASP a7-xss",
                  "Template Injection",
                  "ng-sast"
                ]
              },
              "shortDescription": {
                "text": "Template Injection: HTTP Data Used in HTML Template via r in xss1Handler"
              }
            }
          ],
          "version": "1.0.0"
        }
      }
    }
  ],
  "inlineExternalProperties": [
    {
      "guid": "74250752-2676-4a6a-8011-bcbbf66305af",
      "runGuid": "aff2cd20-f473-4317-9a8e-1516effe59c0"
    }
  ],
  "properties": {}
}
